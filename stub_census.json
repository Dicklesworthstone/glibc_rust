{
  "census_version": 1,
  "generated_utc": "2026-02-11T12:00:00Z",
  "methodology": "Manual trace from todo!() locations in glibc-rs-core through extern C exports in glibc-rs-abi to support_matrix.json status fields. Each stub was checked for whether the ABI layer actually calls into the core stub, or has its own independent implementation.",
  "stubs": [
    {
      "symbol": "iconv_open",
      "abi_module": "iconv_abi.rs",
      "core_location": "crates/glibc-rs-core/src/iconv/mod.rs:15",
      "stub_type": "todo!",
      "stub_message": "POSIX iconv_open: implementation pending",
      "core_fn_signature": "pub fn iconv_open(_tocode: &[u8], _fromcode: &[u8]) -> Option<IconvDescriptor>",
      "abi_exports_symbol": false,
      "abi_calls_core_stub": false,
      "support_matrix_status": null,
      "is_consistent": true,
      "consistency_note": "No ABI export exists and symbol is absent from support_matrix.json. Core stub is dead code. Consistent because the symbol is not yet part of the exported ABI surface.",
      "risk_category": "iconv",
      "call_family": "iconv"
    },
    {
      "symbol": "iconv",
      "abi_module": "iconv_abi.rs",
      "core_location": "crates/glibc-rs-core/src/iconv/mod.rs:27",
      "stub_type": "todo!",
      "stub_message": "POSIX iconv: implementation pending",
      "core_fn_signature": "pub fn iconv(_cd: &mut IconvDescriptor, _inbuf: &[u8], _outbuf: &mut [u8]) -> Result<(usize, usize, usize), i32>",
      "abi_exports_symbol": false,
      "abi_calls_core_stub": false,
      "support_matrix_status": null,
      "is_consistent": true,
      "consistency_note": "No ABI export exists and symbol is absent from support_matrix.json. Core stub is dead code.",
      "risk_category": "iconv",
      "call_family": "iconv"
    },
    {
      "symbol": "iconv_close",
      "abi_module": "iconv_abi.rs",
      "core_location": "crates/glibc-rs-core/src/iconv/mod.rs:34",
      "stub_type": "todo!",
      "stub_message": "POSIX iconv_close: implementation pending",
      "core_fn_signature": "pub fn iconv_close(_cd: IconvDescriptor) -> i32",
      "abi_exports_symbol": false,
      "abi_calls_core_stub": false,
      "support_matrix_status": null,
      "is_consistent": true,
      "consistency_note": "No ABI export exists and symbol is absent from support_matrix.json. Core stub is dead code.",
      "risk_category": "iconv",
      "call_family": "iconv"
    },
    {
      "symbol": "setjmp",
      "abi_module": "setjmp_abi.rs",
      "core_location": "crates/glibc-rs-core/src/setjmp/mod.rs:21",
      "stub_type": "todo!",
      "stub_message": "POSIX setjmp: implementation pending (requires unsafe for real impl)",
      "core_fn_signature": "pub fn setjmp(_env: &mut JmpBuf) -> i32",
      "abi_exports_symbol": false,
      "abi_calls_core_stub": false,
      "support_matrix_status": null,
      "is_consistent": true,
      "consistency_note": "No ABI export exists and symbol is absent from support_matrix.json. Core stub is dead code.",
      "risk_category": "setjmp",
      "call_family": "setjmp"
    },
    {
      "symbol": "longjmp",
      "abi_module": "setjmp_abi.rs",
      "core_location": "crates/glibc-rs-core/src/setjmp/mod.rs:31",
      "stub_type": "todo!",
      "stub_message": "POSIX longjmp: implementation pending (requires unsafe for real impl)",
      "core_fn_signature": "pub fn longjmp(_env: &JmpBuf, _val: i32) -> !",
      "abi_exports_symbol": false,
      "abi_calls_core_stub": false,
      "support_matrix_status": null,
      "is_consistent": true,
      "consistency_note": "No ABI export exists and symbol is absent from support_matrix.json. Core stub is dead code.",
      "risk_category": "setjmp",
      "call_family": "setjmp"
    },
    {
      "symbol": "tcgetattr",
      "abi_module": "termios_abi.rs",
      "core_location": "crates/glibc-rs-core/src/termios/mod.rs:295",
      "stub_type": "todo!",
      "stub_message": "POSIX tcgetattr: implementation pending",
      "core_fn_signature": "pub fn tcgetattr(_fd: i32, _termios: &mut Termios) -> i32",
      "abi_exports_symbol": true,
      "abi_calls_core_stub": false,
      "abi_implementation_note": "ABI layer delegates to libc::tcgetattr() directly (line 39 of termios_abi.rs), bypassing the core stub entirely. Core stub is dead code.",
      "support_matrix_status": "RawSyscall",
      "is_consistent": false,
      "consistency_note": "INCONSISTENCY: support_matrix.json marks tcgetattr as 'RawSyscall' but the ABI implementation calls libc::tcgetattr (a GlibcCallThrough pattern), not a raw syscall. The core todo!() stub is never reached. The status should be 'GlibcCallThrough'.",
      "risk_category": "terminal",
      "call_family": "termios"
    },
    {
      "symbol": "tcsetattr",
      "abi_module": "termios_abi.rs",
      "core_location": "crates/glibc-rs-core/src/termios/mod.rs:303",
      "stub_type": "todo!",
      "stub_message": "POSIX tcsetattr: implementation pending",
      "core_fn_signature": "pub fn tcsetattr(_fd: i32, _optional_actions: i32, _termios: &Termios) -> i32",
      "abi_exports_symbol": true,
      "abi_calls_core_stub": false,
      "abi_implementation_note": "ABI layer delegates to libc::tcsetattr() directly (line 81 of termios_abi.rs), bypassing the core stub entirely. Core stub is dead code.",
      "support_matrix_status": "RawSyscall",
      "is_consistent": false,
      "consistency_note": "INCONSISTENCY: support_matrix.json marks tcsetattr as 'RawSyscall' but the ABI implementation calls libc::tcsetattr (a GlibcCallThrough pattern), not a raw syscall. The core todo!() stub is never reached. The status should be 'GlibcCallThrough'.",
      "risk_category": "terminal",
      "call_family": "termios"
    },
    {
      "symbol": "getaddrinfo",
      "abi_module": "resolv_abi.rs",
      "core_location": "crates/glibc-rs-core/src/resolv/mod.rs:29",
      "stub_type": "todo!",
      "stub_message": "POSIX getaddrinfo: implementation pending",
      "core_fn_signature": "pub fn getaddrinfo(_node: Option<&[u8]>, _service: Option<&[u8]>, _hints: Option<&AddrInfo>) -> Result<Vec<AddrInfo>, i32>",
      "abi_exports_symbol": true,
      "abi_calls_core_stub": false,
      "abi_implementation_note": "ABI layer has its own numeric-address bootstrap implementation (lines 200-307 of resolv_abi.rs) that parses IP addresses directly using std::net. Does not call core resolv::getaddrinfo. Core stub is dead code.",
      "support_matrix_status": "Stub",
      "is_consistent": false,
      "consistency_note": "INCONSISTENCY: support_matrix.json marks getaddrinfo as 'Stub' but the ABI module has a working numeric-address implementation (parses IPv4/IPv6 literals, builds addrinfo structs). This is not a stub -- it should be 'Implemented' (limited to numeric hosts). The core todo!() is never reached.",
      "risk_category": "netdb",
      "call_family": "resolver"
    },
    {
      "symbol": "getnameinfo",
      "abi_module": "resolv_abi.rs",
      "core_location": "crates/glibc-rs-core/src/resolv/mod.rs:36",
      "stub_type": "todo!",
      "stub_message": "POSIX getnameinfo: implementation pending",
      "core_fn_signature": "pub fn getnameinfo(_addr: &[u8], _flags: i32) -> Result<(Vec<u8>, Vec<u8>), i32>",
      "abi_exports_symbol": true,
      "abi_calls_core_stub": false,
      "abi_implementation_note": "ABI layer has its own numeric bootstrap implementation (lines 372-501 of resolv_abi.rs) that converts sockaddr to numeric host/service strings. Does not call core resolv::getnameinfo. Core stub is dead code.",
      "support_matrix_status": "Stub",
      "is_consistent": false,
      "consistency_note": "INCONSISTENCY: support_matrix.json marks getnameinfo as 'Stub' but the ABI module has a working numeric-formatting implementation (formats IPv4/IPv6 to strings). This is not a stub -- it should be 'Implemented' (limited to numeric formatting). The core todo!() is never reached.",
      "risk_category": "netdb",
      "call_family": "resolver"
    },
    {
      "symbol": "pthread_key_create",
      "abi_module": "pthread_abi.rs",
      "core_location": "crates/glibc-rs-core/src/pthread/tls.rs:17",
      "stub_type": "todo!",
      "stub_message": "POSIX pthread_key_create: implementation pending",
      "core_fn_signature": "pub fn pthread_key_create(_key: &mut PthreadKey, _destructor: Option<fn(u64)>) -> i32",
      "abi_exports_symbol": false,
      "abi_calls_core_stub": false,
      "support_matrix_status": null,
      "is_consistent": true,
      "consistency_note": "No ABI export exists and symbol is absent from support_matrix.json. Core stub is dead code.",
      "risk_category": "threading",
      "call_family": "pthread_tls"
    },
    {
      "symbol": "pthread_key_delete",
      "abi_module": "pthread_abi.rs",
      "core_location": "crates/glibc-rs-core/src/pthread/tls.rs:24",
      "stub_type": "todo!",
      "stub_message": "POSIX pthread_key_delete: implementation pending",
      "core_fn_signature": "pub fn pthread_key_delete(_key: PthreadKey) -> i32",
      "abi_exports_symbol": false,
      "abi_calls_core_stub": false,
      "support_matrix_status": null,
      "is_consistent": true,
      "consistency_note": "No ABI export exists and symbol is absent from support_matrix.json. Core stub is dead code.",
      "risk_category": "threading",
      "call_family": "pthread_tls"
    },
    {
      "symbol": "pthread_getspecific",
      "abi_module": "pthread_abi.rs",
      "core_location": "crates/glibc-rs-core/src/pthread/tls.rs:32",
      "stub_type": "todo!",
      "stub_message": "POSIX pthread_getspecific: implementation pending",
      "core_fn_signature": "pub fn pthread_getspecific(_key: PthreadKey) -> u64",
      "abi_exports_symbol": false,
      "abi_calls_core_stub": false,
      "support_matrix_status": null,
      "is_consistent": true,
      "consistency_note": "No ABI export exists and symbol is absent from support_matrix.json. Core stub is dead code.",
      "risk_category": "threading",
      "call_family": "pthread_tls"
    },
    {
      "symbol": "pthread_setspecific",
      "abi_module": "pthread_abi.rs",
      "core_location": "crates/glibc-rs-core/src/pthread/tls.rs:39",
      "stub_type": "todo!",
      "stub_message": "POSIX pthread_setspecific: implementation pending",
      "core_fn_signature": "pub fn pthread_setspecific(_key: PthreadKey, _value: u64) -> i32",
      "abi_exports_symbol": false,
      "abi_calls_core_stub": false,
      "support_matrix_status": null,
      "is_consistent": true,
      "consistency_note": "No ABI export exists and symbol is absent from support_matrix.json. Core stub is dead code.",
      "risk_category": "threading",
      "call_family": "pthread_tls"
    },
    {
      "symbol": "pthread_create",
      "abi_module": "pthread_abi.rs",
      "core_location": "crates/glibc-rs-core/src/pthread/thread.rs:26",
      "stub_type": "todo!",
      "stub_message": "POSIX pthread_create: implementation pending",
      "core_fn_signature": "pub fn pthread_create(_thread: &mut PthreadT, _attr: Option<&PthreadAttr>, _start_routine: fn() -> u64) -> i32",
      "abi_exports_symbol": true,
      "abi_calls_core_stub": false,
      "abi_implementation_note": "ABI layer has its own implementation using std::thread::Builder::new().spawn() (lines 135-206 of pthread_abi.rs). Does not call core pthread::thread::pthread_create. Core stub is dead code.",
      "support_matrix_status": "GlibcCallThrough",
      "is_consistent": false,
      "consistency_note": "INCONSISTENCY: support_matrix.json marks pthread_create as 'GlibcCallThrough' but the ABI implementation uses Rust std::thread (not host glibc pthread_create). This should be 'Implemented'. The core todo!() is never reached.",
      "risk_category": "threading",
      "call_family": "pthread_lifecycle"
    },
    {
      "symbol": "pthread_join",
      "abi_module": "pthread_abi.rs",
      "core_location": "crates/glibc-rs-core/src/pthread/thread.rs:34",
      "stub_type": "todo!",
      "stub_message": "POSIX pthread_join: implementation pending",
      "core_fn_signature": "pub fn pthread_join(_thread: PthreadT) -> Result<u64, i32>",
      "abi_exports_symbol": true,
      "abi_calls_core_stub": false,
      "abi_implementation_note": "ABI layer has its own implementation using Rust JoinHandle::join() (lines 210-259 of pthread_abi.rs). Does not call core pthread::thread::pthread_join. Core stub is dead code.",
      "support_matrix_status": "GlibcCallThrough",
      "is_consistent": false,
      "consistency_note": "INCONSISTENCY: support_matrix.json marks pthread_join as 'GlibcCallThrough' but the ABI implementation uses Rust std::thread JoinHandle (not host glibc pthread_join). This should be 'Implemented'. The core todo!() is never reached.",
      "risk_category": "threading",
      "call_family": "pthread_lifecycle"
    },
    {
      "symbol": "pthread_detach",
      "abi_module": "pthread_abi.rs",
      "core_location": "crates/glibc-rs-core/src/pthread/thread.rs:41",
      "stub_type": "todo!",
      "stub_message": "POSIX pthread_detach: implementation pending",
      "core_fn_signature": "pub fn pthread_detach(_thread: PthreadT) -> i32",
      "abi_exports_symbol": true,
      "abi_calls_core_stub": false,
      "abi_implementation_note": "ABI layer removes the JoinHandle from the join table, allowing thread resources to be reclaimed on termination (lines 263-292 of pthread_abi.rs). Does not call core pthread::thread::pthread_detach. Core stub is dead code.",
      "support_matrix_status": "GlibcCallThrough",
      "is_consistent": false,
      "consistency_note": "INCONSISTENCY: support_matrix.json marks pthread_detach as 'GlibcCallThrough' but the ABI implementation uses Rust internal join table management (not host glibc pthread_detach). This should be 'Implemented'. The core todo!() is never reached.",
      "risk_category": "threading",
      "call_family": "pthread_lifecycle"
    },
    {
      "symbol": "pthread_exit",
      "abi_module": "pthread_abi.rs",
      "core_location": "crates/glibc-rs-core/src/pthread/thread.rs:48",
      "stub_type": "todo!",
      "stub_message": "POSIX pthread_exit: implementation pending",
      "core_fn_signature": "pub fn pthread_exit(_retval: u64) -> !",
      "abi_exports_symbol": false,
      "abi_calls_core_stub": false,
      "support_matrix_status": null,
      "is_consistent": true,
      "consistency_note": "No ABI export exists and symbol is absent from support_matrix.json. Core stub is dead code.",
      "risk_category": "threading",
      "call_family": "pthread_lifecycle"
    },
    {
      "symbol": "pthread_self",
      "abi_module": "pthread_abi.rs",
      "core_location": "crates/glibc-rs-core/src/pthread/thread.rs:55",
      "stub_type": "todo!",
      "stub_message": "POSIX pthread_self: implementation pending",
      "core_fn_signature": "pub fn pthread_self() -> PthreadT",
      "abi_exports_symbol": true,
      "abi_calls_core_stub": false,
      "abi_implementation_note": "ABI layer has its own implementation using thread-local SELF_ID with AtomicU64 counter (lines 89-107 of pthread_abi.rs). Does not call core pthread::thread::pthread_self. Core stub is dead code.",
      "support_matrix_status": "GlibcCallThrough",
      "is_consistent": false,
      "consistency_note": "INCONSISTENCY: support_matrix.json marks pthread_self as 'GlibcCallThrough' but the ABI implementation uses Rust thread-local storage (not host glibc pthread_self). This should be 'Implemented'. The core todo!() is never reached.",
      "risk_category": "threading",
      "call_family": "pthread_lifecycle"
    },
    {
      "symbol": "rand",
      "abi_module": "stdlib_abi.rs",
      "core_location": "crates/glibc-rs-core/src/stdlib/random.rs:5",
      "stub_type": "todo!",
      "stub_message": null,
      "core_fn_signature": "pub fn rand() -> i32",
      "abi_exports_symbol": false,
      "abi_calls_core_stub": false,
      "support_matrix_status": null,
      "is_consistent": true,
      "consistency_note": "No ABI export exists and symbol is absent from support_matrix.json. Core stub is dead code.",
      "risk_category": "stdlib",
      "call_family": "random"
    },
    {
      "symbol": "srand",
      "abi_module": "stdlib_abi.rs",
      "core_location": "crates/glibc-rs-core/src/stdlib/random.rs:8",
      "stub_type": "todo!",
      "stub_message": null,
      "core_fn_signature": "pub fn srand(_seed: u32)",
      "abi_exports_symbol": false,
      "abi_calls_core_stub": false,
      "support_matrix_status": null,
      "is_consistent": true,
      "consistency_note": "No ABI export exists and symbol is absent from support_matrix.json. Core stub is dead code.",
      "risk_category": "stdlib",
      "call_family": "random"
    },
    {
      "symbol": "getenv",
      "abi_module": "stdlib_abi.rs",
      "core_location": "crates/glibc-rs-core/src/stdlib/env.rs:5",
      "stub_type": "todo!",
      "stub_message": null,
      "core_fn_signature": "pub fn getenv(_name: &[u8]) -> Option<&'static [u8]>",
      "abi_exports_symbol": false,
      "abi_calls_core_stub": false,
      "support_matrix_status": null,
      "is_consistent": true,
      "consistency_note": "No ABI export exists and symbol is absent from support_matrix.json. Core stub is dead code.",
      "risk_category": "stdlib",
      "call_family": "env"
    },
    {
      "symbol": "setenv",
      "abi_module": "stdlib_abi.rs",
      "core_location": "crates/glibc-rs-core/src/stdlib/env.rs:8",
      "stub_type": "todo!",
      "stub_message": null,
      "core_fn_signature": "pub fn setenv(_name: &[u8], _value: &[u8], _overwrite: bool) -> i32",
      "abi_exports_symbol": false,
      "abi_calls_core_stub": false,
      "support_matrix_status": null,
      "is_consistent": true,
      "consistency_note": "No ABI export exists and symbol is absent from support_matrix.json. Core stub is dead code.",
      "risk_category": "stdlib",
      "call_family": "env"
    }
  ],
  "inconsistencies": [
    {
      "symbol": "tcgetattr",
      "expected_status": "GlibcCallThrough",
      "actual_status": "RawSyscall",
      "reason": "ABI calls libc::tcgetattr(), which is a glibc call-through, not a raw Linux syscall. The core todo!() stub is never invoked.",
      "core_todo_reachable": false,
      "severity": "medium",
      "fix": "Update support_matrix.json to status 'GlibcCallThrough' for tcgetattr"
    },
    {
      "symbol": "tcsetattr",
      "expected_status": "GlibcCallThrough",
      "actual_status": "RawSyscall",
      "reason": "ABI calls libc::tcsetattr(), which is a glibc call-through, not a raw Linux syscall. The core todo!() stub is never invoked.",
      "core_todo_reachable": false,
      "severity": "medium",
      "fix": "Update support_matrix.json to status 'GlibcCallThrough' for tcsetattr"
    },
    {
      "symbol": "getaddrinfo",
      "expected_status": "Implemented",
      "actual_status": "Stub",
      "reason": "ABI has a working numeric-address bootstrap implementation that parses IPv4/IPv6 literals, builds libc::addrinfo linked lists, and returns 0 on success. This is functional code, not a stub. The core todo!() stub is never invoked.",
      "core_todo_reachable": false,
      "severity": "high",
      "fix": "Update support_matrix.json to status 'Implemented' (or introduce a new status like 'PartiallyImplemented') for getaddrinfo"
    },
    {
      "symbol": "getnameinfo",
      "expected_status": "Implemented",
      "actual_status": "Stub",
      "reason": "ABI has a working numeric-formatting implementation that converts sockaddr_in/sockaddr_in6 to host and service strings. This is functional code, not a stub. The core todo!() stub is never invoked.",
      "core_todo_reachable": false,
      "severity": "high",
      "fix": "Update support_matrix.json to status 'Implemented' (or 'PartiallyImplemented') for getnameinfo"
    },
    {
      "symbol": "freeaddrinfo",
      "expected_status": "Implemented",
      "actual_status": "Stub",
      "reason": "ABI has a working freeaddrinfo implementation that properly deallocates the addrinfo linked list (sockaddr, canonname, and node). No core stub exists for this symbol at all.",
      "core_todo_reachable": false,
      "severity": "high",
      "fix": "Update support_matrix.json to status 'Implemented' for freeaddrinfo"
    },
    {
      "symbol": "gai_strerror",
      "expected_status": "Implemented",
      "actual_status": "Stub",
      "reason": "ABI has a working gai_strerror implementation that returns static C string pointers for all standard EAI_* error codes. This is fully functional, not a stub.",
      "core_todo_reachable": false,
      "severity": "medium",
      "fix": "Update support_matrix.json to status 'Implemented' for gai_strerror"
    },
    {
      "symbol": "pthread_create",
      "expected_status": "Implemented",
      "actual_status": "GlibcCallThrough",
      "reason": "ABI uses Rust std::thread::Builder::spawn(), not host glibc pthread_create. Thread IDs are managed via an internal AtomicU64 counter and join table. The core todo!() stub is never invoked.",
      "core_todo_reachable": false,
      "severity": "high",
      "fix": "Update support_matrix.json to status 'Implemented' for pthread_create"
    },
    {
      "symbol": "pthread_join",
      "expected_status": "Implemented",
      "actual_status": "GlibcCallThrough",
      "reason": "ABI uses Rust JoinHandle::join(), not host glibc pthread_join. The core todo!() stub is never invoked.",
      "core_todo_reachable": false,
      "severity": "high",
      "fix": "Update support_matrix.json to status 'Implemented' for pthread_join"
    },
    {
      "symbol": "pthread_detach",
      "expected_status": "Implemented",
      "actual_status": "GlibcCallThrough",
      "reason": "ABI removes join handle from internal table (Rust-native), not host glibc pthread_detach. The core todo!() stub is never invoked.",
      "core_todo_reachable": false,
      "severity": "high",
      "fix": "Update support_matrix.json to status 'Implemented' for pthread_detach"
    },
    {
      "symbol": "pthread_self",
      "expected_status": "Implemented",
      "actual_status": "GlibcCallThrough",
      "reason": "ABI uses Rust thread_local! SELF_ID with AtomicU64 counter, not host glibc pthread_self. The core todo!() stub is never invoked.",
      "core_todo_reachable": false,
      "severity": "high",
      "fix": "Update support_matrix.json to status 'Implemented' for pthread_self"
    }
  ],
  "summary": {
    "total_todo_stubs_found": 22,
    "todo_stubs_reachable_from_abi": 0,
    "todo_stubs_dead_code": 22,
    "todo_stubs_with_abi_export": 8,
    "todo_stubs_without_abi_export": 14,
    "todo_stubs_in_support_matrix": 8,
    "todo_stubs_missing_from_support_matrix": 14,
    "total_inconsistencies": 10,
    "inconsistencies_by_severity": {
      "high": 7,
      "medium": 3
    },
    "by_risk_category": {
      "iconv": {
        "total_stubs": 3,
        "reachable": 0,
        "dead_code": 3,
        "inconsistencies": 0
      },
      "setjmp": {
        "total_stubs": 2,
        "reachable": 0,
        "dead_code": 2,
        "inconsistencies": 0
      },
      "terminal": {
        "total_stubs": 2,
        "reachable": 0,
        "dead_code": 2,
        "inconsistencies": 2,
        "note": "ABI delegates to libc but support_matrix says RawSyscall"
      },
      "netdb": {
        "total_stubs": 2,
        "reachable": 0,
        "dead_code": 2,
        "inconsistencies": 4,
        "note": "ABI has working numeric implementations but support_matrix says Stub. Includes freeaddrinfo and gai_strerror which have no core todo!() but are misclassified."
      },
      "threading": {
        "total_stubs": 9,
        "reachable": 0,
        "dead_code": 9,
        "inconsistencies": 4,
        "note": "ABI has native Rust implementations but support_matrix says GlibcCallThrough"
      },
      "stdlib": {
        "total_stubs": 4,
        "reachable": 0,
        "dead_code": 4,
        "inconsistencies": 0
      }
    },
    "key_finding": "NONE of the 22 todo!() stubs in glibc-rs-core are reachable from the ABI-exported symbols. In every case where an ABI export exists, the ABI layer has its own independent implementation that bypasses the core stub entirely. The core stubs represent an earlier design phase and are now dead code. However, 10 symbols have incorrect status classifications in support_matrix.json."
  }
}
