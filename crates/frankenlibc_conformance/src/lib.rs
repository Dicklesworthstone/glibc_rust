//! Conformance and parity tooling for glibc_rust.

use std::ffi::{CString, c_char, c_int, c_void};

use serde::{Deserialize, Serialize};

unsafe extern "C" {
    fn wcscpy(dest: *mut libc::wchar_t, src: *const libc::wchar_t) -> *mut libc::wchar_t;
    fn wcsncpy(dest: *mut libc::wchar_t, src: *const libc::wchar_t, n: usize)
    -> *mut libc::wchar_t;
    fn wcscat(dest: *mut libc::wchar_t, src: *const libc::wchar_t) -> *mut libc::wchar_t;
    fn wcscmp(s1: *const libc::wchar_t, s2: *const libc::wchar_t) -> i32;
    fn wcsncmp(s1: *const libc::wchar_t, s2: *const libc::wchar_t, n: usize) -> i32;
    fn wcschr(wcs: *const libc::wchar_t, wc: libc::wchar_t) -> *mut libc::wchar_t;
    fn wcsrchr(wcs: *const libc::wchar_t, wc: libc::wchar_t) -> *mut libc::wchar_t;
    fn wcsstr(haystack: *const libc::wchar_t, needle: *const libc::wchar_t) -> *mut libc::wchar_t;
    fn wmemcpy(dest: *mut libc::wchar_t, src: *const libc::wchar_t, n: usize)
    -> *mut libc::wchar_t;
    fn wmemmove(
        dest: *mut libc::wchar_t,
        src: *const libc::wchar_t,
        n: usize,
    ) -> *mut libc::wchar_t;
    fn wmemset(dest: *mut libc::wchar_t, wc: libc::wchar_t, n: usize) -> *mut libc::wchar_t;
    fn wmemcmp(s1: *const libc::wchar_t, s2: *const libc::wchar_t, n: usize) -> i32;
    fn wmemchr(s: *const libc::wchar_t, wc: libc::wchar_t, n: usize) -> *mut libc::wchar_t;
}

/// Serialized artifact generated by the traceability builder.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TraceabilityArtifact {
    /// Markdown report suitable for humans.
    pub markdown: String,
    /// JSON report suitable for tooling.
    pub json: String,
}

/// Build traceability artifact for the membrane bootstrap phase.
#[must_use]
pub fn build_traceability_artifact() -> TraceabilityArtifact {
    #[cfg(feature = "asupersync-tooling")]
    {
        use asupersync_conformance::TraceabilityMatrixBuilder;

        let mut matrix = TraceabilityMatrixBuilder::new()
            .requirement_with_category(
                "TSM-1",
                "Memcpy-like operations enforce bounds-aware repair",
                "safety",
            )
            .requirement_with_category(
                "TSM-2",
                "Temporal invalid states must deny or repair deterministically",
                "safety",
            )
            .test(
                "TSM-1",
                "decide_copy_repairs_when_exceeding_known_bounds",
                "crates/glibc_rust/src/safety/membrane.rs",
                1,
            )
            .test(
                "TSM-2",
                "decide_copy_denies_when_pointer_non_live",
                "crates/glibc_rust/src/safety/membrane.rs",
                1,
            )
            .build();

        let markdown = matrix.to_markdown();
        let json = match matrix.to_json() {
            Ok(value) => value,
            Err(error) => format!(r#"{{"error":"{error}"}}"#),
        };

        TraceabilityArtifact { markdown, json }
    }

    #[cfg(not(feature = "asupersync-tooling"))]
    {
        TraceabilityArtifact {
            markdown: String::from("# Traceability\n\nBuild without asupersync-tooling feature."),
            json: String::from("{}"),
        }
    }
}

/// Render a textual diff report for expected vs actual output.
#[must_use]
pub fn render_diff_report(expected: &str, actual: &str) -> String {
    #[cfg(feature = "frankentui-ui")]
    {
        return ftui_harness::diff_text(expected, actual);
    }

    #[cfg(not(feature = "frankentui-ui"))]
    {
        if expected == actual {
            return String::from("no-diff");
        }

        format!(
            "expected:\n{expected}\n\nactual:\n{actual}\n\n(note: enable frankentui-ui for rich diffs)"
        )
    }
}

/// Fixture set captured from host libc behavior.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MemcpyFixtureSet {
    /// Schema/version marker.
    pub suite_version: String,
    /// UTC timestamp string.
    pub captured_at_utc: String,
    /// Captured test cases.
    pub cases: Vec<MemcpyCase>,
}

/// Single memcpy test fixture case.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MemcpyCase {
    /// Case identifier.
    pub name: String,
    /// Input source bytes.
    pub src: Vec<u8>,
    /// Initial destination length.
    pub dst_len: usize,
    /// Requested copy length.
    pub requested_len: usize,
    /// Host libc output destination bytes.
    pub expected_dst: Vec<u8>,
}

/// Per-case verification output.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct VerificationCaseResult {
    /// Case identifier.
    pub name: String,
    /// Expected destination bytes.
    pub expected_dst: Vec<u8>,
    /// Actual destination bytes from glibc_rust.
    pub actual_dst: Vec<u8>,
    /// Whether this case passed.
    pub passed: bool,
}

/// Aggregate verification report.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct VerificationReport {
    /// Number of passing cases.
    pub passed: usize,
    /// Number of failing cases.
    pub failed: usize,
    /// Individual case results.
    pub cases: Vec<VerificationCaseResult>,
}

/// Host-vs-implementation execution evidence for one fixture case.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DifferentialExecution {
    /// Output produced by host libc execution (`"UB"` when undefined).
    pub host_output: String,
    /// Output produced by the Rust implementation under selected mode.
    pub impl_output: String,
    /// Whether host and implementation matched when both were defined.
    pub host_parity: bool,
    /// Optional annotation for expected divergences (for hardened mode).
    pub note: Option<String>,
}

/// Execute one fixture case with real host-libc calls and Rust implementation calls.
///
/// Supported fixture functions today:
/// - `memcpy`
/// - `strlen`
pub fn execute_fixture_case(
    function: &str,
    inputs: &serde_json::Value,
    mode: &str,
) -> Result<DifferentialExecution, String> {
    match function {
        "memcpy" => execute_memcpy_case(inputs, mode),
        "memmove" => execute_memmove_case(inputs, mode),
        "strlen" => execute_strlen_case(inputs, mode),
        "memset" => execute_memset_case(inputs, mode),
        "memcmp" => execute_memcmp_case(inputs, mode),
        "memchr" => execute_memchr_case(inputs, mode),
        "memrchr" => execute_memrchr_case(inputs, mode),
        "strcmp" => execute_strcmp_case(inputs, mode),
        "strcpy" => execute_strcpy_case(inputs, mode),
        "strncpy" => execute_strncpy_case(inputs, mode),
        "strcat" => execute_strcat_case(inputs, mode),
        "strncat" => execute_strncat_case(inputs, mode),
        "strchr" => execute_strchr_case(inputs, mode),
        "strrchr" => execute_strrchr_case(inputs, mode),
        "strstr" => execute_strstr_case(inputs, mode),
        "wcslen" => execute_wcslen_case(inputs, mode),
        "wcscpy" => execute_wcscpy_case(inputs, mode),
        "wcscmp" => execute_wcscmp_case(inputs, mode),
        "wcsncpy" => execute_wcsncpy_case(inputs, mode),
        "wcscat" => execute_wcscat_case(inputs, mode),
        "wcsncmp" => execute_wcsncmp_case(inputs, mode),
        "wcschr" => execute_wcschr_case(inputs, mode),
        "wcsrchr" => execute_wcsrchr_case(inputs, mode),
        "wcsstr" => execute_wcsstr_case(inputs, mode),
        "wmemcpy" => execute_wmemcpy_case(inputs, mode),
        "wmemmove" => execute_wmemmove_case(inputs, mode),
        "wmemset" => execute_wmemset_case(inputs, mode),
        "wmemcmp" => execute_wmemcmp_case(inputs, mode),
        "wmemchr" => execute_wmemchr_case(inputs, mode),
        "malloc" => execute_malloc_case(inputs, mode),
        "free" => execute_free_case(inputs, mode),
        "calloc" => execute_calloc_case(inputs, mode),
        "realloc" => execute_realloc_case(inputs, mode),
        "atoi" => execute_atoi_case(inputs, mode),
        "atol" => execute_atol_case(inputs, mode),
        "strtol" => execute_strtol_case(inputs, mode),
        "strtoul" => execute_strtoul_case(inputs, mode),
        "iconv" => execute_iconv_case(inputs, mode),
        "qsort" => execute_qsort_case(inputs, mode),
        "bsearch" => execute_bsearch_case(inputs, mode),
        other => Err(format!("unsupported function: {other}")),
    }
}

// ... existing code ...

fn run_host_qsort(base: &mut [u8]) {
    unsafe extern "C" fn compar(a: *const c_void, b: *const c_void) -> c_int {
        let a_val = unsafe { *(a as *const u8) };
        let b_val = unsafe { *(b as *const u8) };
        (a_val as i32) - (b_val as i32)
    }
    unsafe {
        libc::qsort(base.as_mut_ptr().cast(), base.len(), 1, Some(compar));
    }
}

fn execute_qsort_case(
    inputs: &serde_json::Value,
    mode: &str,
) -> Result<DifferentialExecution, String> {
    let base_orig = parse_u8_vec(inputs, "base")?;
    let _nmemb = parse_usize(inputs, "nmemb")?; // Implied by base len
    let _size = parse_usize(inputs, "size")?; // Assumed 1 for now based on runner

    let strict = mode_is_strict(mode);
    let _hardened = mode_is_hardened(mode);

    // Call core implementation
    let mut impl_base = base_orig.clone();
    // Core qsort expects Fn
    glibc_rs_core::stdlib::sort::qsort(&mut impl_base, 1, |a, b| (a[0] as i32) - (b[0] as i32));
    let impl_output = format!("{:?}", impl_base);

    if strict {
        // Run host
        let mut host_base = base_orig.clone();
        run_host_qsort(&mut host_base);
        let host_output = format!("{:?}", host_base);
        return Ok(DifferentialExecution {
            host_output,
            impl_output,
            host_parity: host_base == impl_base,
            note: None,
        });
    }

    // Hardened logic if needed
    Ok(DifferentialExecution {
        host_output: String::from("SKIP"),
        impl_output,
        host_parity: true,
        note: None,
    })
}

fn run_host_bsearch(key: u8, base: &[u8]) -> bool {
    unsafe extern "C" fn compar(k: *const c_void, e: *const c_void) -> c_int {
        let k_val = unsafe { *(k as *const u8) };
        let e_val = unsafe { *(e as *const u8) };
        (k_val as i32) - (e_val as i32)
    }
    unsafe {
        let k_ptr = &key as *const u8;
        let ptr = libc::bsearch(
            k_ptr.cast(),
            base.as_ptr().cast(),
            base.len(),
            1,
            Some(compar),
        );
        !ptr.is_null()
    }
}

fn execute_bsearch_case(
    inputs: &serde_json::Value,
    mode: &str,
) -> Result<DifferentialExecution, String> {
    let key_vec = parse_u8_vec(inputs, "key")?;
    let base = parse_u8_vec(inputs, "base")?;

    if key_vec.len() != 1 {
        return Err("bsearch key must be 1 byte for this test".into());
    }
    let key = key_vec[0];

    let strict = mode_is_strict(mode);

    // Core implementation
    let result = glibc_rs_core::stdlib::sort::bsearch(&key_vec, &base, 1, |k, e| {
        (k[0] as i32) - (e[0] as i32)
    });
    let impl_output = if result.is_some() { "FOUND" } else { "NULL" };

    if strict {
        let found = run_host_bsearch(key, &base);
        let host_output = if found { "FOUND" } else { "NULL" };
        return Ok(DifferentialExecution {
            host_output: host_output.to_string(),
            impl_output: impl_output.to_string(),
            host_parity: host_output == impl_output,
            note: None,
        });
    }

    Ok(DifferentialExecution {
        host_output: String::from("SKIP"),
        impl_output: impl_output.to_string(),
        host_parity: true,
        note: None,
    })
}
#[must_use]
pub fn capture_memcpy_fixture_set() -> MemcpyFixtureSet {
    let template_cases: [(&str, &[u8], usize, usize); 4] = [
        ("copy_full", b"ABCDEFGH", 8, 8),
        ("copy_partial", b"ABCDEFGH", 8, 4),
        ("copy_zero", b"ABCDEFGH", 8, 0),
        ("copy_single", b"ABCDEFGH", 8, 1),
    ];

    let cases = template_cases
        .into_iter()
        .map(|(name, src, dst_len, requested_len)| MemcpyCase {
            name: name.to_string(),
            src: src.to_vec(),
            dst_len,
            requested_len,
            expected_dst: run_host_memcpy(src, dst_len, requested_len),
        })
        .collect();

    MemcpyFixtureSet {
        suite_version: String::from("memcpy-v1"),
        captured_at_utc: String::from("1970-01-01T00:00:00Z"),
        cases,
    }
}

/// Verify fixture set against current glibc_rust preview memcpy entrypoint.
#[must_use]
pub fn verify_memcpy_fixture_set(fixture: &MemcpyFixtureSet) -> VerificationReport {
    let cases: Vec<VerificationCaseResult> = fixture
        .cases
        .iter()
        .map(|case| {
            let mut dst = vec![0_u8; case.dst_len];
            // SAFETY: Case vectors are intentionally valid and bounded.
            unsafe {
                glibc_rust::glibc_rust_memcpy_preview(
                    dst.as_mut_ptr().cast::<c_void>(),
                    case.src.as_ptr().cast::<c_void>(),
                    case.requested_len,
                );
            }

            let passed = dst == case.expected_dst;
            VerificationCaseResult {
                name: case.name.clone(),
                expected_dst: case.expected_dst.clone(),
                actual_dst: dst,
                passed,
            }
        })
        .collect();

    let passed = cases.iter().filter(|case| case.passed).count();
    let failed = cases.len().saturating_sub(passed);

    VerificationReport {
        passed,
        failed,
        cases,
    }
}

/// Render verification report as markdown.
#[must_use]
pub fn render_verification_markdown(report: &VerificationReport) -> String {
    let mut output = String::new();
    output.push_str("# glibc_rust memcpy verification\n\n");
    output.push_str(&format!("- passed: {}\n", report.passed));
    output.push_str(&format!("- failed: {}\n\n", report.failed));
    output.push_str("| case | status |\n");
    output.push_str("|---|---|\n");

    for case in &report.cases {
        let status = if case.passed { "PASS" } else { "FAIL" };
        output.push_str(&format!("| {} | {} |\n", case.name, status));
    }

    output
}

fn run_host_memcpy(src: &[u8], dst_len: usize, requested_len: usize) -> Vec<u8> {
    let mut dst = vec![0_u8; dst_len];
    let effective_len = requested_len.min(src.len()).min(dst.len());

    if effective_len > 0 {
        // SAFETY: We enforce bounded copy length and non-null valid pointers.
        unsafe {
            libc::memcpy(
                dst.as_mut_ptr().cast::<c_void>(),
                src.as_ptr().cast::<c_void>(),
                effective_len,
            );
        }
    }

    dst
}

fn parse_u8_vec(inputs: &serde_json::Value, key: &str) -> Result<Vec<u8>, String> {
    let arr = inputs
        .get(key)
        .and_then(serde_json::Value::as_array)
        .ok_or_else(|| format!("missing array field '{key}'"))?;
    let mut out = Vec::with_capacity(arr.len());
    for value in arr {
        let byte = value
            .as_u64()
            .ok_or_else(|| format!("non-integer byte in '{key}'"))?;
        if byte > u8::MAX as u64 {
            return Err(format!("byte out of range in '{key}': {byte}"));
        }
        out.push(byte as u8);
    }
    Ok(out)
}

fn parse_u8_vec_any(inputs: &serde_json::Value, keys: &[&str]) -> Result<Vec<u8>, String> {
    for key in keys {
        if let Ok(v) = parse_u8_vec(inputs, key) {
            return Ok(v);
        }
    }
    Err(format!("missing array field from alternatives: {keys:?}"))
}

fn parse_u32_vec(inputs: &serde_json::Value, key: &str) -> Result<Vec<u32>, String> {
    let arr = inputs
        .get(key)
        .and_then(serde_json::Value::as_array)
        .ok_or_else(|| format!("missing array field '{key}'"))?;
    let mut out = Vec::with_capacity(arr.len());
    for value in arr {
        let unit = value
            .as_u64()
            .ok_or_else(|| format!("non-integer code unit in '{key}'"))?;
        if unit > u32::MAX as u64 {
            return Err(format!("code unit out of range in '{key}': {unit}"));
        }
        out.push(unit as u32);
    }
    Ok(out)
}

fn parse_u32_vec_any(inputs: &serde_json::Value, keys: &[&str]) -> Result<Vec<u32>, String> {
    for key in keys {
        if let Ok(v) = parse_u32_vec(inputs, key) {
            return Ok(v);
        }
    }
    Err(format!("missing array field from alternatives: {keys:?}"))
}

fn to_wchar_vec(units: &[u32]) -> Result<Vec<libc::wchar_t>, String> {
    let mut out = Vec::with_capacity(units.len());
    for &unit in units {
        let wide = i32::try_from(unit)
            .map_err(|_| format!("wide code unit out of libc::wchar_t range: {unit}"))?;
        out.push(wide as libc::wchar_t);
    }
    Ok(out)
}

fn from_wchar_vec(units: &[libc::wchar_t]) -> Vec<u32> {
    units.iter().map(|&w| w as u32).collect()
}

fn parse_usize(inputs: &serde_json::Value, key: &str) -> Result<usize, String> {
    inputs
        .get(key)
        .and_then(serde_json::Value::as_u64)
        .map(|v| v as usize)
        .ok_or_else(|| format!("missing integer field '{key}'"))
}

fn parse_usize_any(inputs: &serde_json::Value, keys: &[&str]) -> Result<usize, String> {
    for key in keys {
        if let Ok(v) = parse_usize(inputs, key) {
            return Ok(v);
        }
    }
    Err(format!("missing integer field from alternatives: {keys:?}"))
}

fn parse_i32(inputs: &serde_json::Value, key: &str) -> Result<i32, String> {
    inputs
        .get(key)
        .and_then(serde_json::Value::as_i64)
        .and_then(|v| i32::try_from(v).ok())
        .ok_or_else(|| format!("missing integer field '{key}'"))
}

fn parse_string(inputs: &serde_json::Value, key: &str) -> Result<String, String> {
    inputs
        .get(key)
        .and_then(serde_json::Value::as_str)
        .map(ToOwned::to_owned)
        .ok_or_else(|| format!("missing string field '{key}'"))
}

fn parse_string_any(inputs: &serde_json::Value, keys: &[&str]) -> Result<String, String> {
    for key in keys {
        if let Ok(value) = parse_string(inputs, key) {
            return Ok(value);
        }
    }
    Err(format!("missing string field from alternatives: {keys:?}"))
}

fn parse_c_bytes_any(inputs: &serde_json::Value, keys: &[&str]) -> Result<Vec<u8>, String> {
    for key in keys {
        if let Ok(mut v) = parse_u8_vec(inputs, key) {
            if !v.contains(&0) {
                v.push(0);
            }
            return Ok(v);
        }
    }
    for key in keys {
        if let Ok(text) = parse_string(inputs, key) {
            let mut v = text.into_bytes();
            v.push(0);
            return Ok(v);
        }
    }
    Err(format!(
        "missing C-string field from alternatives: {keys:?}"
    ))
}

fn mode_is_strict(mode: &str) -> bool {
    mode.eq_ignore_ascii_case("strict")
}

fn mode_is_hardened(mode: &str) -> bool {
    mode.eq_ignore_ascii_case("hardened")
}

fn execute_memcpy_case(
    inputs: &serde_json::Value,
    mode: &str,
) -> Result<DifferentialExecution, String> {
    let src = parse_u8_vec(inputs, "src")?;
    let dst_len = parse_usize(inputs, "dst_len")?;
    let requested_len = parse_usize(inputs, "n")?;

    let strict = mode_is_strict(mode);
    let hardened = mode_is_hardened(mode);
    if !strict && !hardened {
        return Err(format!("unsupported mode: {mode}"));
    }

    let defined = requested_len <= src.len() && requested_len <= dst_len;
    let mut impl_dst = vec![0_u8; dst_len];
    let _copied = glibc_rs_core::string::mem::memcpy(&mut impl_dst, &src, requested_len);
    let impl_output = format!("{impl_dst:?}");

    if strict && !defined {
        return Ok(DifferentialExecution {
            host_output: String::from("UB"),
            impl_output: String::from("UB"),
            host_parity: true,
            note: Some(String::from(
                "strict mode leaves undefined behavior undefined",
            )),
        });
    }

    let host_output = if defined {
        format!("{:?}", run_host_memcpy(&src, dst_len, requested_len))
    } else {
        String::from("UB")
    };

    let host_parity = defined && host_output == impl_output;
    let note = if hardened && !defined {
        Some(String::from(
            "hardened mode intentionally clamps undefined host behavior into deterministic output",
        ))
    } else if !host_parity && defined {
        Some(String::from(
            "defined host behavior diverged from Rust implementation",
        ))
    } else {
        None
    };

    Ok(DifferentialExecution {
        host_output,
        impl_output,
        host_parity,
        note,
    })
}

fn run_host_memmove(src: &[u8], dst_len: usize, requested_len: usize) -> Vec<u8> {
    let mut dst = vec![0_u8; dst_len];
    let effective_len = requested_len.min(src.len()).min(dst.len());

    if effective_len > 0 {
        unsafe {
            libc::memmove(
                dst.as_mut_ptr().cast::<c_void>(),
                src.as_ptr().cast::<c_void>(),
                effective_len,
            );
        }
    }
    dst
}

fn execute_memmove_case(
    inputs: &serde_json::Value,
    mode: &str,
) -> Result<DifferentialExecution, String> {
    let src = parse_u8_vec(inputs, "src")?;
    let dst_len = parse_usize(inputs, "dst_len")?;
    let requested_len = parse_usize(inputs, "n")?;

    let strict = mode_is_strict(mode);
    let hardened = mode_is_hardened(mode);
    if !strict && !hardened {
        return Err(format!("unsupported mode: {mode}"));
    }

    let defined = requested_len <= src.len() && requested_len <= dst_len;
    let mut impl_dst = vec![0_u8; dst_len];
    glibc_rs_core::string::mem::memmove(&mut impl_dst, &src, requested_len);
    let impl_output = format!("{impl_dst:?}");

    if strict && !defined {
        return Ok(DifferentialExecution {
            host_output: String::from("UB"),
            impl_output: String::from("UB"),
            host_parity: true,
            note: Some(String::from(
                "strict mode leaves undefined behavior undefined",
            )),
        });
    }

    let host_output = if defined {
        format!("{:?}", run_host_memmove(&src, dst_len, requested_len))
    } else {
        String::from("UB")
    };

    let host_parity = defined && host_output == impl_output;
    let note = if hardened && !defined {
        Some(String::from(
            "hardened mode intentionally clamps undefined host behavior",
        ))
    } else if !host_parity && defined {
        Some(String::from(
            "defined host behavior diverged from Rust implementation",
        ))
    } else {
        None
    };

    Ok(DifferentialExecution {
        host_output,
        impl_output,
        host_parity,
        note,
    })
}

fn run_host_strlen(bytes_with_nul: &[u8]) -> usize {
    // SAFETY: caller ensures `bytes_with_nul` includes a terminating NUL byte.
    unsafe { libc::strlen(bytes_with_nul.as_ptr().cast()) }
}

fn execute_strlen_case(
    inputs: &serde_json::Value,
    mode: &str,
) -> Result<DifferentialExecution, String> {
    let bytes = parse_u8_vec(inputs, "s")?;

    let strict = mode_is_strict(mode);
    let hardened = mode_is_hardened(mode);
    if !strict && !hardened {
        return Err(format!("unsupported mode: {mode}"));
    }

    let has_nul = bytes.contains(&0);
    let impl_len = glibc_rs_core::string::str::strlen(&bytes);
    let impl_output = impl_len.to_string();

    if strict && !has_nul {
        return Ok(DifferentialExecution {
            host_output: String::from("UB"),
            impl_output: String::from("UB"),
            host_parity: true,
            note: Some(String::from(
                "strict mode leaves undefined behavior undefined",
            )),
        });
    }

    let host_output = if has_nul {
        run_host_strlen(&bytes).to_string()
    } else {
        String::from("UB")
    };

    let host_parity = has_nul && host_output == impl_output;
    let note = if hardened && !has_nul {
        Some(String::from(
            "hardened mode returns bounded length where host behavior is undefined",
        ))
    } else if !host_parity && has_nul {
        Some(String::from(
            "defined host behavior diverged from Rust implementation",
        ))
    } else {
        None
    };

    Ok(DifferentialExecution {
        host_output,
        impl_output,
        host_parity,
        note,
    })
}

fn run_host_memset(dst_len: usize, c: i32, n: usize) -> Vec<u8> {
    let mut dst = vec![0_u8; dst_len];
    let effective_len = n.min(dst.len());

    if effective_len > 0 {
        // SAFETY: We enforce bounded length and valid pointers.
        unsafe {
            libc::memset(dst.as_mut_ptr().cast::<c_void>(), c, effective_len);
        }
    }
    dst
}

fn execute_memset_case(
    inputs: &serde_json::Value,
    mode: &str,
) -> Result<DifferentialExecution, String> {
    let dst_len = parse_usize(inputs, "dst_len")?;
    let value = parse_usize(inputs, "value").or_else(|_| parse_usize(inputs, "c"))?;
    if value > u8::MAX as usize {
        return Err(format!("memset value out of range: {value}"));
    }
    let c = value as i32;
    let n = parse_usize(inputs, "n")?;

    let strict = mode_is_strict(mode);
    let hardened = mode_is_hardened(mode);
    if !strict && !hardened {
        return Err(format!("unsupported mode: {mode}"));
    }

    let defined = n <= dst_len;
    let mut impl_dst = vec![0_u8; dst_len];
    glibc_rs_core::string::mem::memset(&mut impl_dst, c as u8, n);
    let impl_output = format!("{impl_dst:?}");

    if strict && !defined {
        return Ok(DifferentialExecution {
            host_output: String::from("UB"),
            impl_output: String::from("UB"),
            host_parity: true,
            note: Some(String::from(
                "strict mode leaves undefined behavior undefined",
            )),
        });
    }

    let host_output = if defined {
        format!("{:?}", run_host_memset(dst_len, c, n))
    } else {
        String::from("UB")
    };

    let host_parity = defined && host_output == impl_output;
    let note = if hardened && !defined {
        Some(String::from(
            "hardened mode intentionally clamps undefined host behavior into deterministic output",
        ))
    } else if !host_parity && defined {
        Some(String::from(
            "defined host behavior diverged from Rust implementation",
        ))
    } else {
        None
    };

    Ok(DifferentialExecution {
        host_output,
        impl_output,
        host_parity,
        note,
    })
}

fn run_host_memcmp(s1: &[u8], s2: &[u8], n: usize) -> i32 {
    // SAFETY: We enforce valid pointers and length.
    unsafe {
        libc::memcmp(
            s1.as_ptr().cast::<c_void>(),
            s2.as_ptr().cast::<c_void>(),
            n,
        )
    }
}

fn execute_memcmp_case(
    inputs: &serde_json::Value,
    mode: &str,
) -> Result<DifferentialExecution, String> {
    let s1 = parse_u8_vec_any(inputs, &["s1", "a", "lhs"])?;
    let s2 = parse_u8_vec_any(inputs, &["s2", "b", "rhs"])?;
    let n = parse_usize(inputs, "n")?;

    let strict = mode_is_strict(mode);
    let hardened = mode_is_hardened(mode);
    if !strict && !hardened {
        return Err(format!("unsupported mode: {mode}"));
    }

    let defined = n <= s1.len() && n <= s2.len();
    let ordering = glibc_rs_core::string::mem::memcmp(&s1, &s2, n);
    let impl_val = match ordering {
        core::cmp::Ordering::Less => -1,
        core::cmp::Ordering::Equal => 0,
        core::cmp::Ordering::Greater => 1,
    };
    let impl_output = format!("{impl_val}");

    if strict && !defined {
        return Ok(DifferentialExecution {
            host_output: String::from("UB"),
            impl_output: String::from("UB"),
            host_parity: true,
            note: Some(String::from(
                "strict mode leaves undefined behavior undefined",
            )),
        });
    }

    let host_output = if defined {
        let val = run_host_memcmp(&s1, &s2, n);
        format!("{}", val.signum())
    } else {
        String::from("UB")
    };

    let host_parity = defined && host_output == impl_output;
    let note = if hardened && !defined {
        Some(String::from(
            "hardened mode intentionally clamps undefined host behavior",
        ))
    } else if !host_parity && defined {
        Some(String::from(
            "defined host behavior diverged from Rust implementation",
        ))
    } else {
        None
    };

    Ok(DifferentialExecution {
        host_output,
        impl_output,
        host_parity,
        note,
    })
}

fn run_host_memchr(s: &[u8], c: i32, n: usize) -> Option<usize> {
    // SAFETY: We enforce valid pointers and length.
    unsafe {
        let ptr = libc::memchr(s.as_ptr().cast::<c_void>(), c, n);
        if ptr.is_null() {
            None
        } else {
            Some(ptr as usize - s.as_ptr() as usize)
        }
    }
}

fn execute_memchr_case(
    inputs: &serde_json::Value,
    mode: &str,
) -> Result<DifferentialExecution, String> {
    let s = parse_u8_vec_any(inputs, &["s", "haystack"])?;
    let c = parse_usize(inputs, "c").or_else(|_| parse_usize(inputs, "needle"))?;
    if c > u8::MAX as usize {
        return Err(format!("memchr needle out of range: {c}"));
    }
    let n = parse_usize(inputs, "n")?;

    let strict = mode_is_strict(mode);
    let hardened = mode_is_hardened(mode);
    if !strict && !hardened {
        return Err(format!("unsupported mode: {mode}"));
    }

    let defined = n <= s.len();
    let impl_val = glibc_rs_core::string::mem::memchr(&s, c as u8, n);
    let impl_output = format!("{impl_val:?}");

    if strict && !defined {
        return Ok(DifferentialExecution {
            host_output: String::from("UB"),
            impl_output: String::from("UB"),
            host_parity: true,
            note: Some(String::from(
                "strict mode leaves undefined behavior undefined",
            )),
        });
    }

    let host_output = if defined {
        format!("{:?}", run_host_memchr(&s, c as i32, n))
    } else {
        String::from("UB")
    };

    let host_parity = defined && host_output == impl_output;
    let note = if hardened && !defined {
        Some(String::from(
            "hardened mode intentionally clamps undefined host behavior",
        ))
    } else if !host_parity && defined {
        Some(String::from(
            "defined host behavior diverged from Rust implementation",
        ))
    } else {
        None
    };

    Ok(DifferentialExecution {
        host_output,
        impl_output,
        host_parity,
        note,
    })
}

fn run_host_memrchr(s: &[u8], c: i32, n: usize) -> Option<usize> {
    // SAFETY: We enforce valid pointers and length.
    unsafe {
        let ptr = libc::memrchr(s.as_ptr().cast::<c_void>(), c, n);
        if ptr.is_null() {
            None
        } else {
            Some(ptr as usize - s.as_ptr() as usize)
        }
    }
}

fn execute_memrchr_case(
    inputs: &serde_json::Value,
    mode: &str,
) -> Result<DifferentialExecution, String> {
    let s = parse_u8_vec_any(inputs, &["s", "haystack"])?;
    let c = parse_usize(inputs, "c").or_else(|_| parse_usize(inputs, "needle"))?;
    if c > u8::MAX as usize {
        return Err(format!("memrchr needle out of range: {c}"));
    }
    let n = parse_usize(inputs, "n")?;

    let strict = mode_is_strict(mode);
    let hardened = mode_is_hardened(mode);
    if !strict && !hardened {
        return Err(format!("unsupported mode: {mode}"));
    }

    let defined = n <= s.len();
    let impl_val = glibc_rs_core::string::mem::memrchr(&s, c as u8, n);
    let impl_output = format!("{impl_val:?}");

    if strict && !defined {
        return Ok(DifferentialExecution {
            host_output: String::from("UB"),
            impl_output: String::from("UB"),
            host_parity: true,
            note: Some(String::from(
                "strict mode leaves undefined behavior undefined",
            )),
        });
    }

    let host_output = if defined {
        format!("{:?}", run_host_memrchr(&s, c as i32, n))
    } else {
        String::from("UB")
    };

    let host_parity = defined && host_output == impl_output;
    let note = if hardened && !defined {
        Some(String::from(
            "hardened mode intentionally clamps undefined host behavior",
        ))
    } else if !host_parity && defined {
        Some(String::from(
            "defined host behavior diverged from Rust implementation",
        ))
    } else {
        None
    };

    Ok(DifferentialExecution {
        host_output,
        impl_output,
        host_parity,
        note,
    })
}

fn run_host_strcmp(s1: &[u8], s2: &[u8]) -> i32 {
    unsafe { libc::strcmp(s1.as_ptr().cast(), s2.as_ptr().cast()) }
}

fn execute_strcmp_case(
    inputs: &serde_json::Value,
    mode: &str,
) -> Result<DifferentialExecution, String> {
    let s1 = parse_u8_vec_any(inputs, &["s1", "lhs", "a"])?;
    let s2 = parse_u8_vec_any(inputs, &["s2", "rhs", "b"])?;

    let strict = mode_is_strict(mode);
    let hardened = mode_is_hardened(mode);
    if !strict && !hardened {
        return Err(format!("unsupported mode: {mode}"));
    }

    let defined = s1.contains(&0) && s2.contains(&0);
    let impl_val = glibc_rs_core::string::str::strcmp(&s1, &s2);

    if strict && !defined {
        return Ok(DifferentialExecution {
            host_output: String::from("UB"),
            impl_output: String::from("UB"),
            host_parity: true,
            note: Some(String::from(
                "strict mode leaves undefined behavior undefined",
            )),
        });
    }

    let host_output = if defined {
        let val = run_host_strcmp(&s1, &s2);
        format!("{}", val.signum()) // Normalize host output
    } else {
        String::from("UB")
    };

    // Normalize both implementations to {-1, 0, 1}.
    let impl_sign = impl_val.signum();
    let impl_output_norm = format!("{}", impl_sign);
    let host_parity = defined && host_output == impl_output_norm;

    let note = if hardened && !defined {
        Some(String::from(
            "hardened mode intentionally clamps undefined host behavior",
        ))
    } else if !host_parity && defined {
        Some(String::from(
            "defined host behavior diverged from Rust implementation",
        ))
    } else {
        None
    };

    Ok(DifferentialExecution {
        host_output,
        impl_output: impl_output_norm,
        host_parity,
        note,
    })
}

fn run_host_strcpy(src: &[u8], dst_len: usize) -> Vec<u8> {
    let mut dst = vec![0_u8; dst_len];
    unsafe {
        libc::strcpy(dst.as_mut_ptr().cast(), src.as_ptr().cast());
    }
    dst
}

fn execute_strcpy_case(
    inputs: &serde_json::Value,
    mode: &str,
) -> Result<DifferentialExecution, String> {
    let src = parse_u8_vec(inputs, "src")?;
    let dst_len = parse_usize(inputs, "dst_len")?;

    let strict = mode_is_strict(mode);
    let hardened = mode_is_hardened(mode);
    if !strict && !hardened {
        return Err(format!("unsupported mode: {mode}"));
    }

    let src_len = src.iter().position(|&c| c == 0).unwrap_or(src.len());
    let defined = src.contains(&0) && dst_len > src_len;

    // We copy input src to a safe impl src that won't panic if read past end by core if it was naive (it's not).
    // Core strcpy panics if dest too small. We need to catch that or ensure we only call it safely?
    // "Panics if dest is too small".
    // We should probably catch unwind or check bounds before calling if we want to report UB/Error instead of crash.
    // But for "strict", a crash/panic is a valid way to represent "undefined behavior" or "abort" in Rust.
    // However, the test runner shouldn't crash.

    // We'll emulate the check:
    if strict && !defined {
        return Ok(DifferentialExecution {
            host_output: String::from("UB"),
            impl_output: String::from("UB"), // Or "Panic"
            host_parity: true,
            note: Some(String::from(
                "strict mode leaves undefined behavior undefined",
            )),
        });
    }

    let mut impl_dst = vec![0_u8; dst_len];
    // This might panic if dst_len is too small even if defined check failed above?
    // defined = dst_len > src_len. So it fits.

    if defined {
        glibc_rs_core::string::str::strcpy(&mut impl_dst, &src);
    } else if hardened && dst_len > 0 {
        let copy_len = src_len.min(dst_len.saturating_sub(1));
        impl_dst[..copy_len].copy_from_slice(&src[..copy_len]);
        impl_dst[copy_len] = 0;
    }
    let impl_output = format!("{impl_dst:?}");

    let host_output = if defined {
        format!("{:?}", run_host_strcpy(&src, dst_len))
    } else {
        String::from("UB")
    };

    let host_parity = defined && host_output == impl_output;
    let note = if hardened && !defined {
        Some(String::from(
            "hardened mode handles overflow safely (implementation detail)",
        ))
    } else if !host_parity && defined {
        Some(String::from("defined host behavior diverged"))
    } else {
        None
    };

    Ok(DifferentialExecution {
        host_output,
        impl_output,
        host_parity,
        note,
    })
}

fn run_host_strncpy(src: &[u8], dst_len: usize, n: usize) -> Vec<u8> {
    let mut dst = vec![0_u8; dst_len];
    unsafe {
        libc::strncpy(dst.as_mut_ptr().cast(), src.as_ptr().cast(), n);
    }
    dst
}

fn execute_strncpy_case(
    inputs: &serde_json::Value,
    mode: &str,
) -> Result<DifferentialExecution, String> {
    let src = parse_u8_vec(inputs, "src")?;
    let dst_len = parse_usize(inputs, "dst_len")?;
    let n = parse_usize(inputs, "n")?;

    let strict = mode_is_strict(mode);
    let hardened = mode_is_hardened(mode);
    if !strict && !hardened {
        return Err(format!("unsupported mode: {mode}"));
    }

    // strncpy is defined even if src is not null terminated, it just stops at n.
    // UB if dst is too small? No, strncpy writes exactly n (padded with 0).
    // It writes to dst[0..n]. So UB if n > dst_len.

    let defined = n <= dst_len; // And src is valid for reading? src is slice.

    let mut impl_dst = vec![0_u8; dst_len];
    if defined {
        glibc_rs_core::string::str::strncpy(&mut impl_dst, &src, n);
    } else if hardened {
        let effective_n = n.min(dst_len);
        // strncpy uses src until null or n. src_len is index of null.
        // We find actual bytes to copy.
        let to_copy = src
            .iter()
            .take(effective_n)
            .position(|&c| c == 0)
            .unwrap_or(effective_n);
        impl_dst[..to_copy].copy_from_slice(&src[..to_copy]);
        if to_copy < effective_n {
            impl_dst[to_copy..effective_n].fill(0);
        }
    }
    let impl_output = format!("{impl_dst:?}");

    if strict && !defined {
        return Ok(DifferentialExecution {
            host_output: String::from("UB"),
            impl_output: String::from("UB"),
            host_parity: true,
            note: Some(String::from(
                "strict mode leaves undefined behavior undefined",
            )),
        });
    }

    let host_output = if defined {
        format!("{:?}", run_host_strncpy(&src, dst_len, n))
    } else {
        String::from("UB")
    };

    let host_parity = defined && host_output == impl_output;

    Ok(DifferentialExecution {
        host_output,
        impl_output,
        host_parity,
        note: if hardened && !defined {
            Some(String::from(
                "hardened mode intentionally clamps undefined host behavior",
            ))
        } else {
            None
        },
    })
}

fn run_host_strcat(dst_in: &[u8], src: &[u8], dst_cap: usize) -> Vec<u8> {
    let mut dst = vec![0_u8; dst_cap];
    // initialize dst
    let init_len = dst_in.iter().position(|&c| c == 0).unwrap_or(dst_in.len());
    unsafe {
        std::ptr::copy_nonoverlapping(dst_in.as_ptr(), dst.as_mut_ptr(), init_len.min(dst_cap));
    }
    if init_len < dst_cap {
        dst[init_len] = 0;
    }

    unsafe {
        libc::strcat(dst.as_mut_ptr().cast(), src.as_ptr().cast());
    }
    dst
}

fn execute_strcat_case(
    inputs: &serde_json::Value,
    mode: &str,
) -> Result<DifferentialExecution, String> {
    let dst_init = parse_u8_vec(inputs, "dst_init")?;
    let src = parse_u8_vec(inputs, "src")?;
    let dst_cap = parse_usize(inputs, "dst_cap")?;

    let strict = mode_is_strict(mode);
    let hardened = mode_is_hardened(mode);
    if !strict && !hardened {
        return Err(format!("unsupported mode: {mode}"));
    }

    let dst_len_input = dst_init
        .iter()
        .position(|&c| c == 0)
        .unwrap_or(dst_init.len());
    let src_len = src.iter().position(|&c| c == 0).unwrap_or(src.len());

    let defined = dst_init.contains(&0) && src.contains(&0) && (dst_len_input + src_len < dst_cap);

    let mut impl_dst = vec![0_u8; dst_cap];
    // setup impl_dst
    let setup_len = dst_len_input.min(dst_cap);
    impl_dst[..setup_len].copy_from_slice(&dst_init[..setup_len]);
    if setup_len < dst_cap {
        impl_dst[setup_len] = 0;
    }

    if defined {
        glibc_rs_core::string::str::strcat(&mut impl_dst, &src);
    } else if hardened {
        // Calculate effective length in the initialized buffer
        let current_len = impl_dst
            .iter()
            .position(|&c| c == 0)
            .unwrap_or(impl_dst.len());

        if current_len < dst_cap {
            let avail = dst_cap.saturating_sub(current_len).saturating_sub(1);
            let copy_len = src_len.min(avail);
            impl_dst[current_len..current_len + copy_len].copy_from_slice(&src[..copy_len]);
            if current_len + copy_len < dst_cap {
                impl_dst[current_len + copy_len] = 0;
            }
        } else {
            // Buffer is full/unterminated. Force truncation if possible.
            if dst_cap > 0 {
                impl_dst[dst_cap - 1] = 0;
            }
        }
    }
    let impl_output = format!("{impl_dst:?}");

    if strict && !defined {
        return Ok(DifferentialExecution {
            host_output: String::from("UB"),
            impl_output: String::from("UB"),
            host_parity: true,
            note: Some(String::from(
                "strict mode leaves undefined behavior undefined",
            )),
        });
    }

    let host_output = if defined {
        format!("{:?}", run_host_strcat(&dst_init, &src, dst_cap))
    } else {
        String::from("UB")
    };

    let host_parity = defined && host_output == impl_output;

    Ok(DifferentialExecution {
        host_output,
        impl_output,
        host_parity,
        note: if hardened && !defined {
            Some(String::from(
                "hardened mode intentionally clamps undefined host behavior",
            ))
        } else {
            None
        },
    })
}

fn run_host_strncat(dst_in: &[u8], src: &[u8], n: usize, dst_cap: usize) -> Vec<u8> {
    let mut dst = vec![0_u8; dst_cap];
    let init_len = dst_in.iter().position(|&c| c == 0).unwrap_or(dst_in.len());
    unsafe {
        std::ptr::copy_nonoverlapping(dst_in.as_ptr(), dst.as_mut_ptr(), init_len.min(dst_cap));
    }
    if init_len < dst_cap {
        dst[init_len] = 0;
    }

    unsafe {
        libc::strncat(dst.as_mut_ptr().cast(), src.as_ptr().cast(), n);
    }
    dst
}

fn execute_strncat_case(
    inputs: &serde_json::Value,
    mode: &str,
) -> Result<DifferentialExecution, String> {
    let dst_init = parse_u8_vec(inputs, "dst_init")?;
    let src = parse_u8_vec(inputs, "src")?;
    let n = parse_usize(inputs, "n")?;
    let dst_cap = parse_usize(inputs, "dst_cap")?;

    let strict = mode_is_strict(mode);
    let hardened = mode_is_hardened(mode);
    if !strict && !hardened {
        return Err(format!("unsupported mode: {mode}"));
    }

    let dst_len = dst_init
        .iter()
        .position(|&c| c == 0)
        .unwrap_or(dst_init.len());
    let src_len = src.iter().position(|&c| c == 0).unwrap_or(src.len());
    let copy_len = src_len.min(n);

    let defined = dst_init.contains(&0) && (dst_len + copy_len < dst_cap);
    // src doesn't strictly need to be null terminated for strncat if n < src_len?
    // POSIX: "reads at most n bytes from src". If null byte in src is reached, it stops.

    let mut impl_dst = vec![0_u8; dst_cap];
    let setup_len = dst_len.min(dst_cap);
    impl_dst[..setup_len].copy_from_slice(&dst_init[..setup_len]);
    if setup_len < dst_cap {
        impl_dst[setup_len] = 0;
    }

    if defined {
        glibc_rs_core::string::str::strncat(&mut impl_dst, &src, n);
    }
    let impl_output = format!("{impl_dst:?}");

    if strict && !defined {
        return Ok(DifferentialExecution {
            host_output: String::from("UB"),
            impl_output: String::from("UB"),
            host_parity: true,
            note: Some(String::from(
                "strict mode leaves undefined behavior undefined",
            )),
        });
    }

    let host_output = if defined {
        format!("{:?}", run_host_strncat(&dst_init, &src, n, dst_cap))
    } else {
        String::from("UB")
    };

    let host_parity = defined && host_output == impl_output;

    Ok(DifferentialExecution {
        host_output,
        impl_output,
        host_parity,
        note: if hardened && !defined {
            Some(String::from(
                "hardened mode intentionally clamps undefined host behavior",
            ))
        } else {
            None
        },
    })
}

fn run_host_strchr(s: &[u8], c: i32) -> Option<usize> {
    unsafe {
        let ptr = libc::strchr(s.as_ptr().cast(), c);
        if ptr.is_null() {
            None
        } else {
            Some(ptr as usize - s.as_ptr() as usize)
        }
    }
}

fn execute_strchr_case(
    inputs: &serde_json::Value,
    mode: &str,
) -> Result<DifferentialExecution, String> {
    let s = parse_u8_vec_any(inputs, &["s", "haystack"])?;
    let c = parse_usize(inputs, "c").or_else(|_| parse_usize(inputs, "needle"))?;
    if c > u8::MAX as usize {
        return Err(format!("strchr needle out of range: {c}"));
    }
    let strict = mode_is_strict(mode);
    let hardened = mode_is_hardened(mode);
    if !strict && !hardened {
        return Err(format!("unsupported mode: {mode}"));
    }

    let defined = s.contains(&0);

    let impl_val = if defined {
        glibc_rs_core::string::str::strchr(&s, c as u8)
    } else {
        None
    };
    let impl_output = format!("{impl_val:?}");

    if strict && !defined {
        return Ok(DifferentialExecution {
            host_output: String::from("UB"),
            impl_output: String::from("UB"),
            host_parity: true,
            note: None,
        });
    }

    let host_output = if defined {
        format!("{:?}", run_host_strchr(&s, c as i32))
    } else {
        String::from("UB")
    };

    let host_parity = defined && host_output == impl_output;

    Ok(DifferentialExecution {
        host_output,
        impl_output,
        host_parity,
        note: None,
    })
}

fn run_host_strrchr(s: &[u8], c: i32) -> Option<usize> {
    unsafe {
        let ptr = libc::strrchr(s.as_ptr().cast(), c);
        if ptr.is_null() {
            None
        } else {
            Some(ptr as usize - s.as_ptr() as usize)
        }
    }
}

fn execute_strrchr_case(
    inputs: &serde_json::Value,
    mode: &str,
) -> Result<DifferentialExecution, String> {
    let s = parse_u8_vec_any(inputs, &["s", "haystack"])?;
    let c = parse_usize(inputs, "c").or_else(|_| parse_usize(inputs, "needle"))?;
    if c > u8::MAX as usize {
        return Err(format!("strrchr needle out of range: {c}"));
    }
    let strict = mode_is_strict(mode);
    let hardened = mode_is_hardened(mode);
    if !strict && !hardened {
        return Err(format!("unsupported mode: {mode}"));
    }

    let defined = s.contains(&0);

    let impl_val = if defined {
        glibc_rs_core::string::str::strrchr(&s, c as u8)
    } else {
        None
    };
    let impl_output = format!("{impl_val:?}");

    if strict && !defined {
        return Ok(DifferentialExecution {
            host_output: String::from("UB"),
            impl_output: String::from("UB"),
            host_parity: true,
            note: Some(String::from(
                "strict mode leaves undefined behavior undefined",
            )),
        });
    }

    let host_output = if defined {
        format!("{:?}", run_host_strrchr(&s, c as i32))
    } else {
        String::from("UB")
    };

    let host_parity = defined && host_output == impl_output;

    Ok(DifferentialExecution {
        host_output,
        impl_output,
        host_parity,
        note: if hardened && !defined {
            Some(String::from(
                "hardened mode intentionally clamps undefined host behavior",
            ))
        } else {
            None
        },
    })
}

fn run_host_strstr(hay: &[u8], needle: &[u8]) -> Option<usize> {
    unsafe {
        let ptr = libc::strstr(hay.as_ptr().cast(), needle.as_ptr().cast());
        if ptr.is_null() {
            None
        } else {
            Some(ptr as usize - hay.as_ptr() as usize)
        }
    }
}

fn execute_strstr_case(
    inputs: &serde_json::Value,
    mode: &str,
) -> Result<DifferentialExecution, String> {
    let hay = parse_u8_vec(inputs, "haystack")?;
    let needle = parse_u8_vec(inputs, "needle")?;
    let strict = mode_is_strict(mode);
    let hardened = mode_is_hardened(mode);
    if !strict && !hardened {
        return Err(format!("unsupported mode: {mode}"));
    }

    let defined = hay.contains(&0) && needle.contains(&0);

    let impl_val = if defined {
        glibc_rs_core::string::str::strstr(&hay, &needle)
    } else {
        None
    };
    let impl_output = format!("{impl_val:?}");

    if strict && !defined {
        return Ok(DifferentialExecution {
            host_output: String::from("UB"),
            impl_output: String::from("UB"),
            host_parity: true,
            note: Some(String::from(
                "strict mode leaves undefined behavior undefined",
            )),
        });
    }

    let host_output = if defined {
        format!("{:?}", run_host_strstr(&hay, &needle))
    } else {
        String::from("UB")
    };

    let host_parity = defined && host_output == impl_output;

    Ok(DifferentialExecution {
        host_output,
        impl_output,
        host_parity,
        note: if hardened && !defined {
            Some(String::from(
                "hardened mode intentionally clamps undefined host behavior",
            ))
        } else {
            None
        },
    })
}

fn run_host_wcslen(s: &[u32]) -> Result<usize, String> {
    let wide = to_wchar_vec(s)?;
    // SAFETY: pointer is valid for converted wide string; callers gate UB by mode/inputs.
    Ok(unsafe { libc::wcslen(wide.as_ptr()) })
}

fn execute_wcslen_case(
    inputs: &serde_json::Value,
    mode: &str,
) -> Result<DifferentialExecution, String> {
    let s = parse_u32_vec_any(inputs, &["s", "ws"])?;
    let strict = mode_is_strict(mode);
    let hardened = mode_is_hardened(mode);
    if !strict && !hardened {
        return Err(format!("unsupported mode: {mode}"));
    }

    let has_nul = s.contains(&0);
    let impl_len = glibc_rs_core::string::wide::wcslen(&s);
    let impl_output = impl_len.to_string();

    if strict && !has_nul {
        return Ok(DifferentialExecution {
            host_output: String::from("UB"),
            impl_output: String::from("UB"),
            host_parity: true,
            note: Some(String::from(
                "strict mode leaves undefined behavior undefined",
            )),
        });
    }

    let host_output = if has_nul {
        run_host_wcslen(&s)?.to_string()
    } else {
        String::from("UB")
    };

    let host_parity = has_nul && host_output == impl_output;
    let note = if hardened && !has_nul {
        Some(String::from(
            "hardened mode returns bounded length where host behavior is undefined",
        ))
    } else if !host_parity && has_nul {
        Some(String::from(
            "defined host behavior diverged from Rust implementation",
        ))
    } else {
        None
    };

    Ok(DifferentialExecution {
        host_output,
        impl_output,
        host_parity,
        note,
    })
}

fn run_host_wcscpy(src: &[u32], dst_len: usize) -> Result<Vec<u32>, String> {
    let src_wide = to_wchar_vec(src)?;
    let mut dst_wide = vec![0 as libc::wchar_t; dst_len];
    // SAFETY: callers gate UB cases (src NUL-terminated, destination capacity sufficient).
    unsafe {
        wcscpy(dst_wide.as_mut_ptr(), src_wide.as_ptr());
    }
    Ok(from_wchar_vec(&dst_wide))
}

fn execute_wcscpy_case(
    inputs: &serde_json::Value,
    mode: &str,
) -> Result<DifferentialExecution, String> {
    let src = parse_u32_vec_any(inputs, &["src", "s"])?;
    let dst_len = parse_usize(inputs, "dst_len")?;
    let strict = mode_is_strict(mode);
    let hardened = mode_is_hardened(mode);
    if !strict && !hardened {
        return Err(format!("unsupported mode: {mode}"));
    }

    let src_len = src.iter().position(|&c| c == 0).unwrap_or(src.len());
    let defined = src.contains(&0) && dst_len > src_len;

    if strict && !defined {
        return Ok(DifferentialExecution {
            host_output: String::from("UB"),
            impl_output: String::from("UB"),
            host_parity: true,
            note: Some(String::from(
                "strict mode leaves undefined behavior undefined",
            )),
        });
    }

    let mut impl_dst = vec![0u32; dst_len];
    if defined {
        glibc_rs_core::string::wide::wcscpy(&mut impl_dst, &src);
    } else if hardened && dst_len > 0 {
        // Deterministic repair: clamp to fit and force a trailing NUL.
        let copy_len = src_len.min(dst_len.saturating_sub(1));
        impl_dst[..copy_len].copy_from_slice(&src[..copy_len]);
        impl_dst[copy_len] = 0;
    }
    let impl_output = format!("{impl_dst:?}");

    let host_output = if defined {
        format!("{:?}", run_host_wcscpy(&src, dst_len)?)
    } else {
        String::from("UB")
    };

    let host_parity = defined && host_output == impl_output;
    let note = if hardened && !defined {
        Some(String::from(
            "hardened mode truncates undefined host behavior into deterministic output",
        ))
    } else if !host_parity && defined {
        Some(String::from(
            "defined host behavior diverged from Rust implementation",
        ))
    } else {
        None
    };

    Ok(DifferentialExecution {
        host_output,
        impl_output,
        host_parity,
        note,
    })
}

fn run_host_wcscmp(s1: &[u32], s2: &[u32]) -> Result<i32, String> {
    let s1_wide = to_wchar_vec(s1)?;
    let s2_wide = to_wchar_vec(s2)?;
    // SAFETY: callers gate UB cases so both strings are NUL-terminated.
    Ok(unsafe { wcscmp(s1_wide.as_ptr(), s2_wide.as_ptr()).signum() })
}

fn execute_wcscmp_case(
    inputs: &serde_json::Value,
    mode: &str,
) -> Result<DifferentialExecution, String> {
    let s1 = parse_u32_vec_any(inputs, &["s1", "lhs", "a"])?;
    let s2 = parse_u32_vec_any(inputs, &["s2", "rhs", "b"])?;
    let strict = mode_is_strict(mode);
    let hardened = mode_is_hardened(mode);
    if !strict && !hardened {
        return Err(format!("unsupported mode: {mode}"));
    }

    let defined = s1.contains(&0) && s2.contains(&0);

    if strict && !defined {
        return Ok(DifferentialExecution {
            host_output: String::from("UB"),
            impl_output: String::from("UB"),
            host_parity: true,
            note: Some(String::from(
                "strict mode leaves undefined behavior undefined",
            )),
        });
    }

    let impl_output = glibc_rs_core::string::wide::wcscmp(&s1, &s2)
        .signum()
        .to_string();

    let host_output = if defined {
        run_host_wcscmp(&s1, &s2)?.to_string()
    } else {
        String::from("UB")
    };

    let host_parity = defined && host_output == impl_output;
    let note = if hardened && !defined {
        Some(String::from(
            "hardened mode clamps undefined host behavior into deterministic output",
        ))
    } else if !host_parity && defined {
        Some(String::from(
            "defined host behavior diverged from Rust implementation",
        ))
    } else {
        None
    };

    Ok(DifferentialExecution {
        host_output,
        impl_output,
        host_parity,
        note,
    })
}

fn run_host_wcsncmp(s1: &[u32], s2: &[u32], n: usize) -> Result<i32, String> {
    let s1_wide = to_wchar_vec(s1)?;
    let s2_wide = to_wchar_vec(s2)?;
    unsafe { Ok(wcsncmp(s1_wide.as_ptr(), s2_wide.as_ptr(), n).signum()) }
}

fn execute_wcsncmp_case(
    inputs: &serde_json::Value,
    mode: &str,
) -> Result<DifferentialExecution, String> {
    let s1 = parse_u32_vec_any(inputs, &["s1", "lhs", "a"])?;
    let s2 = parse_u32_vec_any(inputs, &["s2", "rhs", "b"])?;
    let n = parse_usize(inputs, "n")?;
    let strict = mode_is_strict(mode);
    let hardened = mode_is_hardened(mode);
    if !strict && !hardened {
        return Err(format!("unsupported mode: {mode}"));
    }

    let impl_output = glibc_rs_core::string::wide::wcsncmp(&s1, &s2, n)
        .signum()
        .to_string();
    let host_output = run_host_wcsncmp(&s1, &s2, n)?.to_string();
    Ok(DifferentialExecution {
        host_parity: host_output == impl_output,
        host_output,
        impl_output,
        note: None,
    })
}

fn run_host_wcsncpy(src: &[u32], dst_len: usize, n: usize) -> Result<Vec<u32>, String> {
    let src_wide = to_wchar_vec(src)?;
    let mut dst_wide = vec![0 as libc::wchar_t; dst_len];
    unsafe {
        wcsncpy(dst_wide.as_mut_ptr(), src_wide.as_ptr(), n);
    }
    Ok(from_wchar_vec(&dst_wide))
}

fn execute_wcsncpy_case(
    inputs: &serde_json::Value,
    mode: &str,
) -> Result<DifferentialExecution, String> {
    let src = parse_u32_vec_any(inputs, &["src", "s"])?;
    let dst_len = parse_usize(inputs, "dst_len")?;
    let n = parse_usize(inputs, "n")?;

    let strict = mode_is_strict(mode);
    let hardened = mode_is_hardened(mode);
    if !strict && !hardened {
        return Err(format!("unsupported mode: {mode}"));
    }

    let defined = dst_len >= n;

    if strict && !defined {
        return Ok(DifferentialExecution {
            host_output: String::from("UB"),
            impl_output: String::from("UB"),
            host_parity: true,
            note: Some(String::from(
                "strict mode leaves undefined behavior undefined",
            )),
        });
    }

    let mut impl_dst = vec![0u32; dst_len];
    if defined {
        glibc_rs_core::string::wide::wcsncpy(&mut impl_dst, &src, n);
    } else if hardened {
        let effective_n = n.min(dst_len);
        let src_len = glibc_rs_core::string::wide::wcslen(&src);
        let copy_len = src_len.min(effective_n);
        impl_dst[..copy_len].copy_from_slice(&src[..copy_len]);
        if copy_len < effective_n {
            impl_dst[copy_len..effective_n].fill(0);
        }
    }
    let impl_output = format!("{impl_dst:?}");

    let host_output = if defined {
        format!("{:?}", run_host_wcsncpy(&src, dst_len, n)?)
    } else {
        String::from("UB")
    };

    let host_parity = defined && host_output == impl_output;
    let note = if hardened && !defined {
        Some(String::from("hardened mode clamps undefined host behavior"))
    } else if !host_parity && defined {
        Some(String::from("defined host behavior diverged"))
    } else {
        None
    };

    Ok(DifferentialExecution {
        host_output,
        impl_output,
        host_parity,
        note,
    })
}

fn run_host_wcscat(dst_in: &[u32], src: &[u32], dst_cap: usize) -> Result<Vec<u32>, String> {
    let mut dst_wide = vec![0 as libc::wchar_t; dst_cap];
    let dst_in_wide = to_wchar_vec(dst_in)?;
    let src_wide = to_wchar_vec(src)?;

    let init_len = dst_in_wide
        .iter()
        .position(|&c| c == 0)
        .unwrap_or(dst_in_wide.len());
    let setup_len = init_len.min(dst_cap);
    unsafe {
        std::ptr::copy_nonoverlapping(dst_in_wide.as_ptr(), dst_wide.as_mut_ptr(), setup_len);
    }
    if setup_len < dst_cap {
        dst_wide[setup_len] = 0;
    }

    unsafe {
        wcscat(dst_wide.as_mut_ptr(), src_wide.as_ptr());
    }
    Ok(from_wchar_vec(&dst_wide))
}

fn execute_wcscat_case(
    inputs: &serde_json::Value,
    mode: &str,
) -> Result<DifferentialExecution, String> {
    let dst_init = parse_u32_vec(inputs, "dst_init")?;
    let src = parse_u32_vec(inputs, "src")?;
    let dst_cap = parse_usize(inputs, "dst_cap")?;

    let strict = mode_is_strict(mode);
    let hardened = mode_is_hardened(mode);
    if !strict && !hardened {
        return Err(format!("unsupported mode: {mode}"));
    }

    let dst_len_input = glibc_rs_core::string::wide::wcslen(&dst_init);
    let src_len = glibc_rs_core::string::wide::wcslen(&src);
    let defined = dst_init.contains(&0) && src.contains(&0) && (dst_len_input + src_len < dst_cap);

    if strict && !defined {
        return Ok(DifferentialExecution {
            host_output: String::from("UB"),
            impl_output: String::from("UB"),
            host_parity: true,
            note: Some(String::from(
                "strict mode leaves undefined behavior undefined",
            )),
        });
    }

    let mut impl_dst = vec![0u32; dst_cap];
    let setup_len = dst_len_input.min(dst_cap);
    impl_dst[..setup_len].copy_from_slice(&dst_init[..setup_len]);
    if setup_len < dst_cap {
        impl_dst[setup_len] = 0;
    }

    if defined {
        glibc_rs_core::string::wide::wcscat(&mut impl_dst, &src);
    } else if hardened {
        // Calculate effective length in the initialized buffer
        let current_len = glibc_rs_core::string::wide::wcslen(&impl_dst);

        if current_len < dst_cap {
            let avail = dst_cap.saturating_sub(current_len).saturating_sub(1);
            let copy_len = src_len.min(avail);
            if copy_len > 0 {
                impl_dst[current_len..current_len + copy_len].copy_from_slice(&src[..copy_len]);
            }
            if current_len + copy_len < dst_cap {
                impl_dst[current_len + copy_len] = 0;
            }
        } else {
            // Buffer is full/unterminated. Force truncation if possible.
            if dst_cap > 0 {
                impl_dst[dst_cap - 1] = 0;
            }
        }
    }
    let impl_output = format!("{impl_dst:?}");

    let host_output = if defined {
        format!("{:?}", run_host_wcscat(&dst_init, &src, dst_cap)?)
    } else {
        String::from("UB")
    };

    let host_parity = defined && host_output == impl_output;
    let note = if hardened && !defined {
        Some(String::from("hardened mode clamps"))
    } else if !host_parity && defined {
        Some(String::from("divergence"))
    } else {
        None
    };

    Ok(DifferentialExecution {
        host_output,
        impl_output,
        host_parity,
        note,
    })
}

fn run_host_wcschr(s: &[u32], c: u32) -> Result<Option<usize>, String> {
    let s_wide = to_wchar_vec(s)?;
    let c_wide = c as libc::wchar_t;
    unsafe {
        let ptr = wcschr(s_wide.as_ptr(), c_wide);
        if ptr.is_null() {
            Ok(None)
        } else {
            Ok(Some(ptr as usize - s_wide.as_ptr() as usize))
        }
    }
}

fn execute_wcschr_case(
    inputs: &serde_json::Value,
    mode: &str,
) -> Result<DifferentialExecution, String> {
    let s = parse_u32_vec_any(inputs, &["s", "haystack"])?;
    let c = parse_usize(inputs, "c")? as u32;

    let strict = mode_is_strict(mode);
    let hardened = mode_is_hardened(mode);
    if !strict && !hardened {
        return Err(format!("unsupported mode: {mode}"));
    }

    let defined = s.contains(&0);
    if strict && !defined {
        return Ok(DifferentialExecution {
            host_output: String::from("UB"),
            impl_output: String::from("UB"),
            host_parity: true,
            note: Some(String::from("strict UB")),
        });
    }

    let impl_val = if defined {
        glibc_rs_core::string::wide::wcschr(&s, c)
    } else {
        None
    };
    let impl_output = format!("{impl_val:?}");

    let host_output = if defined {
        format!("{:?}", run_host_wcschr(&s, c)?)
    } else {
        String::from("UB")
    };

    let host_parity = defined && host_output == impl_output;
    Ok(DifferentialExecution {
        host_output,
        impl_output,
        host_parity,
        note: None,
    })
}

fn run_host_wcsrchr(s: &[u32], c: u32) -> Result<Option<usize>, String> {
    let s_wide = to_wchar_vec(s)?;
    let c_wide = c as libc::wchar_t;
    unsafe {
        let ptr = wcsrchr(s_wide.as_ptr(), c_wide);
        if ptr.is_null() {
            Ok(None)
        } else {
            Ok(Some(ptr as usize - s_wide.as_ptr() as usize))
        }
    }
}

fn execute_wcsrchr_case(
    inputs: &serde_json::Value,
    mode: &str,
) -> Result<DifferentialExecution, String> {
    let s = parse_u32_vec_any(inputs, &["s", "haystack"])?;
    let c = parse_usize(inputs, "c")? as u32;
    let strict = mode_is_strict(mode);
    let hardened = mode_is_hardened(mode);
    if !strict && !hardened {
        return Err(format!("unsupported mode: {mode}"));
    }

    let defined = s.contains(&0);
    if strict && !defined {
        return Ok(DifferentialExecution {
            host_output: String::from("UB"),
            impl_output: String::from("UB"),
            host_parity: true,
            note: Some(String::from("strict UB")),
        });
    }

    let impl_val = if defined {
        glibc_rs_core::string::wide::wcsrchr(&s, c)
    } else {
        None
    };
    let impl_output = format!("{impl_val:?}");

    let host_output = if defined {
        format!("{:?}", run_host_wcsrchr(&s, c)?)
    } else {
        String::from("UB")
    };

    Ok(DifferentialExecution {
        host_parity: defined && host_output == impl_output,
        host_output,
        impl_output,
        note: None,
    })
}

fn run_host_wcsstr(hay: &[u32], needle: &[u32]) -> Result<Option<usize>, String> {
    let hay_wide = to_wchar_vec(hay)?;
    let needle_wide = to_wchar_vec(needle)?;
    unsafe {
        let ptr = wcsstr(hay_wide.as_ptr(), needle_wide.as_ptr());
        if ptr.is_null() {
            Ok(None)
        } else {
            Ok(Some(ptr as usize - hay_wide.as_ptr() as usize))
        }
    }
}

fn execute_wcsstr_case(
    inputs: &serde_json::Value,
    mode: &str,
) -> Result<DifferentialExecution, String> {
    let hay = parse_u32_vec(inputs, "haystack")?;
    let needle = parse_u32_vec(inputs, "needle")?;
    let strict = mode_is_strict(mode);
    let hardened = mode_is_hardened(mode);
    if !strict && !hardened {
        return Err(format!("unsupported mode: {mode}"));
    }

    let defined = hay.contains(&0) && needle.contains(&0);
    if strict && !defined {
        return Ok(DifferentialExecution {
            host_output: String::from("UB"),
            impl_output: String::from("UB"),
            host_parity: true,
            note: Some(String::from("strict UB")),
        });
    }

    let impl_val = if defined {
        glibc_rs_core::string::wide::wcsstr(&hay, &needle)
    } else {
        None
    };
    let impl_output = format!("{impl_val:?}");
    let host_output = if defined {
        format!("{:?}", run_host_wcsstr(&hay, &needle)?)
    } else {
        String::from("UB")
    };

    Ok(DifferentialExecution {
        host_parity: defined && host_output == impl_output,
        host_output,
        impl_output,
        note: None,
    })
}

fn run_host_wmemcpy(src: &[u32], dst_len: usize, n: usize) -> Result<Vec<u32>, String> {
    let src_wide = to_wchar_vec(src)?;
    let mut dst_wide = vec![0 as libc::wchar_t; dst_len];
    let copy_len = n.min(src_wide.len()).min(dst_wide.len());
    if copy_len > 0 {
        unsafe {
            wmemcpy(dst_wide.as_mut_ptr(), src_wide.as_ptr(), copy_len);
        }
    }
    Ok(from_wchar_vec(&dst_wide))
}

fn execute_wmemcpy_case(
    inputs: &serde_json::Value,
    mode: &str,
) -> Result<DifferentialExecution, String> {
    let src = parse_u32_vec(inputs, "src")?;
    let dst_len = parse_usize(inputs, "dst_len")?;
    let n = parse_usize(inputs, "n")?;
    let strict = mode_is_strict(mode);
    let hardened = mode_is_hardened(mode);
    if !strict && !hardened {
        return Err(format!("unsupported mode: {mode}"));
    }

    let mut impl_dst = vec![0u32; dst_len];
    glibc_rs_core::string::wide::wmemmove(&mut impl_dst, &src, n);
    let impl_output = format!("{impl_dst:?}");
    let host_output = format!("{:?}", run_host_wmemcpy(&src, dst_len, n)?);

    Ok(DifferentialExecution {
        host_parity: host_output == impl_output,
        host_output,
        impl_output,
        note: None,
    })
}

fn run_host_wmemmove(src: &[u32], dst_len: usize, n: usize) -> Result<Vec<u32>, String> {
    let src_wide = to_wchar_vec(src)?;
    let mut dst_wide = vec![0 as libc::wchar_t; dst_len];
    let copy_len = n.min(src_wide.len()).min(dst_wide.len());
    if copy_len > 0 {
        unsafe {
            wmemmove(dst_wide.as_mut_ptr(), src_wide.as_ptr(), copy_len);
        }
    }
    Ok(from_wchar_vec(&dst_wide))
}

fn execute_wmemmove_case(
    inputs: &serde_json::Value,
    mode: &str,
) -> Result<DifferentialExecution, String> {
    let src = parse_u32_vec(inputs, "src")?;
    let dst_len = parse_usize(inputs, "dst_len")?;
    let n = parse_usize(inputs, "n")?;
    let strict = mode_is_strict(mode);
    let hardened = mode_is_hardened(mode);
    if !strict && !hardened {
        return Err(format!("unsupported mode: {mode}"));
    }

    let mut impl_dst = vec![0u32; dst_len];
    glibc_rs_core::string::wide::wmemmove(&mut impl_dst, &src, n);
    let impl_output = format!("{impl_dst:?}");
    let host_output = format!("{:?}", run_host_wmemmove(&src, dst_len, n)?);

    Ok(DifferentialExecution {
        host_parity: host_output == impl_output,
        host_output,
        impl_output,
        note: None,
    })
}

fn run_host_wmemset(dst_len: usize, c: u32, n: usize) -> Result<Vec<u32>, String> {
    let mut dst_wide = vec![0 as libc::wchar_t; dst_len];
    let fill_len = n.min(dst_wide.len());
    if fill_len > 0 {
        unsafe {
            wmemset(dst_wide.as_mut_ptr(), c as libc::wchar_t, fill_len);
        }
    }
    Ok(from_wchar_vec(&dst_wide))
}

fn execute_wmemset_case(
    inputs: &serde_json::Value,
    mode: &str,
) -> Result<DifferentialExecution, String> {
    let dst_len = parse_usize(inputs, "dst_len")?;
    let c = parse_usize(inputs, "c")? as u32;
    let n = parse_usize(inputs, "n")?;
    let strict = mode_is_strict(mode);
    let hardened = mode_is_hardened(mode);
    if !strict && !hardened {
        return Err(format!("unsupported mode: {mode}"));
    }

    let mut impl_dst = vec![0u32; dst_len];
    glibc_rs_core::string::wide::wmemset(&mut impl_dst, c, n);
    let impl_output = format!("{impl_dst:?}");
    let host_output = format!("{:?}", run_host_wmemset(dst_len, c, n)?);

    Ok(DifferentialExecution {
        host_parity: host_output == impl_output,
        host_output,
        impl_output,
        note: None,
    })
}

fn run_host_wmemcmp(s1: &[u32], s2: &[u32], n: usize) -> Result<i32, String> {
    let s1_wide = to_wchar_vec(s1)?;
    let s2_wide = to_wchar_vec(s2)?;
    let cmp_len = n.min(s1_wide.len()).min(s2_wide.len());
    if cmp_len == 0 {
        return Ok(0);
    }
    unsafe { Ok(wmemcmp(s1_wide.as_ptr(), s2_wide.as_ptr(), cmp_len).signum()) }
}

fn execute_wmemcmp_case(
    inputs: &serde_json::Value,
    mode: &str,
) -> Result<DifferentialExecution, String> {
    let s1 = parse_u32_vec(inputs, "s1")?;
    let s2 = parse_u32_vec(inputs, "s2")?;
    let n = parse_usize(inputs, "n")?;
    let strict = mode_is_strict(mode);
    let hardened = mode_is_hardened(mode);
    if !strict && !hardened {
        return Err(format!("unsupported mode: {mode}"));
    }

    let impl_output = glibc_rs_core::string::wide::wmemcmp(&s1, &s2, n).to_string();
    let host_output = run_host_wmemcmp(&s1, &s2, n)?.to_string();
    Ok(DifferentialExecution {
        host_parity: host_output == impl_output,
        host_output,
        impl_output,
        note: None,
    })
}

fn run_host_wmemchr(s: &[u32], c: u32, n: usize) -> Result<Option<usize>, String> {
    let s_wide = to_wchar_vec(s)?;
    let scan_len = n.min(s_wide.len());
    if scan_len == 0 {
        return Ok(None);
    }
    unsafe {
        let ptr = wmemchr(s_wide.as_ptr(), c as libc::wchar_t, scan_len);
        if ptr.is_null() {
            Ok(None)
        } else {
            Ok(Some(ptr as usize - s_wide.as_ptr() as usize))
        }
    }
}

fn execute_wmemchr_case(
    inputs: &serde_json::Value,
    mode: &str,
) -> Result<DifferentialExecution, String> {
    let s = parse_u32_vec(inputs, "s")?;
    let c = parse_usize(inputs, "c")? as u32;
    let n = parse_usize(inputs, "n")?;
    let strict = mode_is_strict(mode);
    let hardened = mode_is_hardened(mode);
    if !strict && !hardened {
        return Err(format!("unsupported mode: {mode}"));
    }

    let impl_output = format!("{:?}", glibc_rs_core::string::wide::wmemchr(&s, c, n));
    let host_output = format!("{:?}", run_host_wmemchr(&s, c, n)?);
    Ok(DifferentialExecution {
        host_parity: host_output == impl_output,
        host_output,
        impl_output,
        note: None,
    })
}

fn run_host_malloc(size: usize) -> bool {
    unsafe {
        let ptr = libc::malloc(size);
        let valid = size == 0 || !ptr.is_null();
        if !ptr.is_null() {
            libc::free(ptr);
        }
        valid
    }
}

fn execute_malloc_case(
    inputs: &serde_json::Value,
    mode: &str,
) -> Result<DifferentialExecution, String> {
    let strict = mode_is_strict(mode);
    let hardened = mode_is_hardened(mode);
    if !strict && !hardened {
        return Err(format!("unsupported mode: {mode}"));
    }

    let size = parse_usize(inputs, "size")?;
    let impl_ptr = unsafe { glibc_rust::glibc_rust_malloc_preview(size) };
    let impl_valid = size == 0 || !impl_ptr.is_null();
    if !impl_ptr.is_null() {
        unsafe { glibc_rust::glibc_rust_free_preview(impl_ptr, size.max(1)) };
    }

    let host_valid = run_host_malloc(size);
    let output_str = |valid: bool| if valid { "ALLOCATED" } else { "NULL" };

    Ok(DifferentialExecution {
        host_output: output_str(host_valid).to_string(),
        impl_output: output_str(impl_valid).to_string(),
        host_parity: host_valid == impl_valid,
        note: if size == 0 {
            Some(String::from(
                "malloc(0) normalized to ALLOCATED because POSIX permits NULL or unique pointer",
            ))
        } else {
            None
        },
    })
}

fn execute_free_case(
    inputs: &serde_json::Value,
    mode: &str,
) -> Result<DifferentialExecution, String> {
    let strict = mode_is_strict(mode);
    let hardened = mode_is_hardened(mode);
    if !strict && !hardened {
        return Err(format!("unsupported mode: {mode}"));
    }

    let ptr_val = parse_usize_any(inputs, &["ptr_val", "size_hint"]).unwrap_or(0);
    if ptr_val == 0 {
        unsafe {
            libc::free(std::ptr::null_mut());
            glibc_rust::glibc_rust_free_preview(std::ptr::null_mut(), 0);
        }
    } else {
        let host_ptr = unsafe { libc::malloc(ptr_val.max(1)) };
        if !host_ptr.is_null() {
            unsafe { libc::free(host_ptr) };
        }
        let impl_ptr = unsafe { glibc_rust::glibc_rust_malloc_preview(ptr_val.max(1)) };
        if !impl_ptr.is_null() {
            unsafe { glibc_rust::glibc_rust_free_preview(impl_ptr, ptr_val.max(1)) };
        }
    }
    Ok(DifferentialExecution {
        host_output: "OK".to_string(),
        impl_output: "OK".to_string(),
        host_parity: true,
        note: None,
    })
}

fn run_host_calloc(nmemb: usize, size: usize) -> (bool, bool) {
    let Some(total) = nmemb.checked_mul(size) else {
        return (false, true);
    };
    unsafe {
        let ptr = libc::calloc(nmemb, size);
        if ptr.is_null() {
            return (total == 0, true);
        }
        let probe_len = total.min(64);
        let zeroed = if total == 0 {
            true
        } else {
            let probe = std::slice::from_raw_parts(ptr.cast::<u8>(), probe_len);
            probe.iter().all(|&b| b == 0)
        };
        libc::free(ptr);
        (true, zeroed)
    }
}

fn execute_calloc_case(
    inputs: &serde_json::Value,
    mode: &str,
) -> Result<DifferentialExecution, String> {
    let strict = mode_is_strict(mode);
    let hardened = mode_is_hardened(mode);
    if !strict && !hardened {
        return Err(format!("unsupported mode: {mode}"));
    }

    let nmemb = parse_usize(inputs, "nmemb")?;
    let size = parse_usize(inputs, "size")?;
    let total = nmemb.checked_mul(size).unwrap_or(0);

    let impl_ptr = unsafe { glibc_rust::glibc_rust_calloc_preview(nmemb, size) };
    let impl_valid = total == 0 || !impl_ptr.is_null();
    let impl_zeroed = if impl_ptr.is_null() || total == 0 {
        true
    } else {
        let probe_len = total.min(64);
        let probe = unsafe { std::slice::from_raw_parts(impl_ptr.cast::<u8>(), probe_len) };
        probe.iter().all(|&b| b == 0)
    };
    if !impl_ptr.is_null() {
        unsafe { glibc_rust::glibc_rust_free_preview(impl_ptr, total.max(1)) };
    }

    let (host_valid, host_zeroed) = run_host_calloc(nmemb, size);
    let output_str = |valid: bool, zeroed: bool| {
        if valid && zeroed {
            "ALLOCATED"
        } else if valid {
            "NONZERO"
        } else {
            "NULL"
        }
    };

    Ok(DifferentialExecution {
        host_output: output_str(host_valid, host_zeroed).to_string(),
        impl_output: output_str(impl_valid, impl_zeroed).to_string(),
        host_parity: host_valid == impl_valid && host_zeroed == impl_zeroed,
        note: None,
    })
}

fn run_host_realloc(ptr_val: usize, old_size: usize, size: usize) -> bool {
    unsafe {
        if ptr_val == 0 {
            let new_ptr = libc::realloc(std::ptr::null_mut(), size);
            let valid = size == 0 || !new_ptr.is_null();
            if !new_ptr.is_null() {
                libc::free(new_ptr);
            }
            valid
        } else {
            let old_ptr = libc::malloc(old_size.max(1));
            if old_ptr.is_null() {
                false
            } else {
                let new_ptr = libc::realloc(old_ptr, size);
                let valid = size == 0 || !new_ptr.is_null();
                if !new_ptr.is_null() {
                    libc::free(new_ptr);
                }
                valid
            }
        }
    }
}

fn execute_realloc_case(
    inputs: &serde_json::Value,
    mode: &str,
) -> Result<DifferentialExecution, String> {
    let strict = mode_is_strict(mode);
    let hardened = mode_is_hardened(mode);
    if !strict && !hardened {
        return Err(format!("unsupported mode: {mode}"));
    }

    let ptr_val = parse_usize_any(inputs, &["ptr_val", "old_size_hint"]).unwrap_or(0);
    let size = parse_usize_any(inputs, &["size", "new_size"])?;
    let old_size = parse_usize_any(inputs, &["old_size", "old_size_hint"]).unwrap_or(ptr_val);

    let impl_valid = if ptr_val == 0 {
        let ptr = unsafe { glibc_rust::glibc_rust_realloc_preview(std::ptr::null_mut(), size, 0) };
        let valid = size == 0 || !ptr.is_null();
        if !ptr.is_null() {
            unsafe { glibc_rust::glibc_rust_free_preview(ptr, size.max(1)) };
        }
        valid
    } else {
        let src = unsafe { glibc_rust::glibc_rust_malloc_preview(old_size.max(1)) };
        if src.is_null() {
            false
        } else {
            let ptr = unsafe { glibc_rust::glibc_rust_realloc_preview(src, size, old_size.max(1)) };
            let valid = size == 0 || !ptr.is_null();
            if !ptr.is_null() {
                unsafe { glibc_rust::glibc_rust_free_preview(ptr, size.max(1)) };
            }
            valid
        }
    };

    let host_valid = run_host_realloc(ptr_val, old_size, size);
    let output_str = |valid: bool| if valid { "ALLOCATED" } else { "NULL" };

    Ok(DifferentialExecution {
        host_output: output_str(host_valid).to_string(),
        impl_output: output_str(impl_valid).to_string(),
        host_parity: host_valid == impl_valid,
        note: None,
    })
}

fn run_host_atoi(s: &[u8]) -> i32 {
    let mut s_safe = s.to_vec();
    if !s_safe.contains(&0) {
        s_safe.push(0);
    }
    unsafe { libc::atoi(s_safe.as_ptr().cast()) }
}

fn execute_atoi_case(
    inputs: &serde_json::Value,
    mode: &str,
) -> Result<DifferentialExecution, String> {
    let s = parse_c_bytes_any(inputs, &["s", "nptr"])?;
    let strict = mode_is_strict(mode);
    let hardened = mode_is_hardened(mode);
    if !strict && !hardened {
        return Err(format!("unsupported mode: {mode}"));
    }

    let has_nul = s.contains(&0);
    let impl_val = glibc_rs_core::stdlib::atoi(&s[..s.len().saturating_sub(1)]);
    let impl_output = impl_val.to_string();

    if strict && !has_nul {
        return Ok(DifferentialExecution {
            host_output: String::from("UB"),
            impl_output: String::from("UB"),
            host_parity: true,
            note: Some(String::from(
                "strict mode leaves undefined behavior undefined",
            )),
        });
    }

    let host_output = run_host_atoi(&s).to_string();
    let host_parity = host_output == impl_output;

    Ok(DifferentialExecution {
        host_output,
        impl_output,
        host_parity,
        note: None,
    })
}

fn run_host_atol(s: &[u8]) -> i64 {
    let mut s_safe = s.to_vec();
    if !s_safe.contains(&0) {
        s_safe.push(0);
    }
    unsafe { libc::atol(s_safe.as_ptr().cast()) }
}

fn execute_atol_case(
    inputs: &serde_json::Value,
    mode: &str,
) -> Result<DifferentialExecution, String> {
    let s = parse_c_bytes_any(inputs, &["s", "nptr"])?;
    let strict = mode_is_strict(mode);
    let hardened = mode_is_hardened(mode);
    if !strict && !hardened {
        return Err(format!("unsupported mode: {mode}"));
    }

    let has_nul = s.contains(&0);
    let impl_val = glibc_rs_core::stdlib::atol(&s[..s.len().saturating_sub(1)]);
    let impl_output = impl_val.to_string();

    if strict && !has_nul {
        return Ok(DifferentialExecution {
            host_output: String::from("UB"),
            impl_output: String::from("UB"),
            host_parity: true,
            note: Some(String::from(
                "strict mode leaves undefined behavior undefined",
            )),
        });
    }

    let host_output = run_host_atol(&s).to_string();
    let host_parity = host_output == impl_output;

    Ok(DifferentialExecution {
        host_output,
        impl_output,
        host_parity,
        note: None,
    })
}

fn run_host_strtol(s: &[u8], base: i32) -> i64 {
    let mut s_safe = s.to_vec();
    if !s_safe.contains(&0) {
        s_safe.push(0);
    }
    unsafe { libc::strtol(s_safe.as_ptr().cast(), std::ptr::null_mut(), base) }
}

fn execute_strtol_case(
    inputs: &serde_json::Value,
    mode: &str,
) -> Result<DifferentialExecution, String> {
    let s = parse_c_bytes_any(inputs, &["s", "nptr"])?;
    let base = parse_i32(inputs, "base").unwrap_or(10);
    let strict = mode_is_strict(mode);
    let hardened = mode_is_hardened(mode);
    if !strict && !hardened {
        return Err(format!("unsupported mode: {mode}"));
    }

    let has_nul = s.contains(&0);
    let (impl_val, _len) = glibc_rs_core::stdlib::strtol(&s[..s.len().saturating_sub(1)], base);
    let impl_output = impl_val.to_string();

    if strict && !has_nul {
        return Ok(DifferentialExecution {
            host_output: String::from("UB"),
            impl_output: String::from("UB"),
            host_parity: true,
            note: Some(String::from(
                "strict mode leaves undefined behavior undefined",
            )),
        });
    }

    let host_output = run_host_strtol(&s, base).to_string();
    let host_parity = host_output == impl_output;

    Ok(DifferentialExecution {
        host_output,
        impl_output,
        host_parity,
        note: None,
    })
}

fn run_host_strtoul(s: &[u8], base: i32) -> u64 {
    let mut s_safe = s.to_vec();
    if !s_safe.contains(&0) {
        s_safe.push(0);
    }
    unsafe { libc::strtoul(s_safe.as_ptr().cast(), std::ptr::null_mut(), base) }
}

fn execute_strtoul_case(
    inputs: &serde_json::Value,
    mode: &str,
) -> Result<DifferentialExecution, String> {
    let s = parse_c_bytes_any(inputs, &["s", "nptr"])?;
    let base = parse_i32(inputs, "base").unwrap_or(10);
    let strict = mode_is_strict(mode);
    let hardened = mode_is_hardened(mode);
    if !strict && !hardened {
        return Err(format!("unsupported mode: {mode}"));
    }

    let has_nul = s.contains(&0);
    let (impl_val, _len) = glibc_rs_core::stdlib::strtoul(&s[..s.len().saturating_sub(1)], base);
    let impl_output = impl_val.to_string();

    if strict && !has_nul {
        return Ok(DifferentialExecution {
            host_output: String::from("UB"),
            impl_output: String::from("UB"),
            host_parity: true,
            note: Some(String::from(
                "strict mode leaves undefined behavior undefined",
            )),
        });
    }

    let host_output = run_host_strtoul(&s, base).to_string();
    let host_parity = host_output == impl_output;

    Ok(DifferentialExecution {
        host_output,
        impl_output,
        host_parity,
        note: None,
    })
}

fn format_iconv_open_error(errno: i32) -> String {
    format!("open_err errno={errno}")
}

fn format_iconv_success(
    non_reversible: usize,
    in_left: usize,
    out_left: usize,
    out: &[u8],
) -> String {
    format!("ok nonrev={non_reversible} in_left={in_left} out_left={out_left} out={out:?}")
}

fn format_iconv_error(errno: i32, in_left: usize, out_left: usize, out: &[u8]) -> String {
    format!("err errno={errno} in_left={in_left} out_left={out_left} out={out:?}")
}

fn run_host_iconv_case(
    tocode: &str,
    fromcode: &str,
    input: &[u8],
    out_len: usize,
) -> Result<String, String> {
    const ICONV_ERROR_VALUE: usize = usize::MAX;

    let tocode_c = CString::new(tocode).map_err(|_| "tocode contains interior NUL".to_string())?;
    let fromcode_c =
        CString::new(fromcode).map_err(|_| "fromcode contains interior NUL".to_string())?;

    // SAFETY: writing errno is thread-local and valid for this process.
    unsafe {
        *libc::__errno_location() = 0;
    }
    // SAFETY: tocode/fromcode are valid C strings.
    let cd = unsafe { libc::iconv_open(tocode_c.as_ptr(), fromcode_c.as_ptr()) };
    if (cd as usize) == ICONV_ERROR_VALUE {
        // SAFETY: reading errno is valid in this thread.
        let host_errno = unsafe { *libc::__errno_location() };
        return Ok(format_iconv_open_error(host_errno));
    }

    let mut input_buf = input.to_vec();
    let mut in_ptr = input_buf.as_mut_ptr().cast::<c_char>();
    let mut in_left = input_buf.len();
    let mut output = vec![0u8; out_len];
    let mut out_ptr = output.as_mut_ptr().cast::<c_char>();
    let mut out_left = output.len();

    // SAFETY: writing errno is thread-local and valid for this process.
    unsafe {
        *libc::__errno_location() = 0;
    }
    // SAFETY: iconv descriptor is valid; pointers/lengths are derived from owned buffers.
    let rc = unsafe { libc::iconv(cd, &mut in_ptr, &mut in_left, &mut out_ptr, &mut out_left) };
    // SAFETY: reading errno is valid in this thread.
    let host_errno = unsafe { *libc::__errno_location() };
    // SAFETY: descriptor came from successful iconv_open.
    unsafe {
        libc::iconv_close(cd);
    }

    let written = out_len.saturating_sub(out_left);
    output.truncate(written);

    if rc == ICONV_ERROR_VALUE {
        Ok(format_iconv_error(host_errno, in_left, out_left, &output))
    } else {
        Ok(format_iconv_success(rc, in_left, out_left, &output))
    }
}

fn run_impl_iconv_case(tocode: &str, fromcode: &str, input: &[u8], out_len: usize) -> String {
    let Some(mut cd) = glibc_rs_core::iconv::iconv_open(tocode.as_bytes(), fromcode.as_bytes())
    else {
        return format_iconv_open_error(glibc_rs_core::iconv::ICONV_EINVAL);
    };

    let mut output = vec![0u8; out_len];
    let rendered = match glibc_rs_core::iconv::iconv(&mut cd, input, &mut output) {
        Ok(result) => {
            let in_left = input.len().saturating_sub(result.in_consumed);
            let out_left = out_len.saturating_sub(result.out_written);
            output.truncate(result.out_written);
            format_iconv_success(result.non_reversible, in_left, out_left, &output)
        }
        Err(err) => {
            let in_left = input.len().saturating_sub(err.in_consumed);
            let out_left = out_len.saturating_sub(err.out_written);
            output.truncate(err.out_written);
            format_iconv_error(err.code, in_left, out_left, &output)
        }
    };
    let _ = glibc_rs_core::iconv::iconv_close(cd);
    rendered
}

fn execute_iconv_case(
    inputs: &serde_json::Value,
    mode: &str,
) -> Result<DifferentialExecution, String> {
    let strict = mode_is_strict(mode);
    let hardened = mode_is_hardened(mode);
    if !strict && !hardened {
        return Err(format!("unsupported mode: {mode}"));
    }

    let tocode = parse_string_any(inputs, &["tocode", "to"])?;
    let fromcode = parse_string_any(inputs, &["fromcode", "from"])?;
    let input = parse_u8_vec_any(inputs, &["input", "inbuf", "src"])?;
    let out_len = parse_usize_any(inputs, &["out_len", "dst_len", "outbytesleft"])?;

    let impl_output = run_impl_iconv_case(&tocode, &fromcode, &input, out_len);

    if strict {
        let host_output = run_host_iconv_case(&tocode, &fromcode, &input, out_len)?;
        let host_parity = host_output == impl_output;
        let note =
            (!host_parity).then(|| "strict host parity mismatch for iconv conversion".to_string());
        return Ok(DifferentialExecution {
            host_output,
            impl_output,
            host_parity,
            note,
        });
    }

    Ok(DifferentialExecution {
        host_output: String::from("SKIP"),
        impl_output,
        host_parity: true,
        note: None,
    })
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn artifact_contains_content() {
        let artifact = build_traceability_artifact();
        assert!(!artifact.markdown.is_empty());
        assert!(!artifact.json.is_empty());
    }

    #[test]
    fn fallback_diff_marks_no_diff() {
        let report = render_diff_report("same", "same");
        assert!(report.contains("no-diff") || report.contains("same"));
    }

    #[test]
    fn capture_and_verify_memcpy_fixture_set() {
        let fixture = capture_memcpy_fixture_set();
        let report = verify_memcpy_fixture_set(&fixture);
        assert_eq!(report.failed, 0);
        assert_eq!(report.passed, fixture.cases.len());
    }

    #[test]
    fn execute_memcpy_case_uses_host_diff_for_defined_inputs() {
        let inputs = serde_json::json!({
            "src": [65, 66, 67, 68],
            "dst_len": 4,
            "n": 4
        });
        let result = execute_fixture_case("memcpy", &inputs, "strict")
            .expect("memcpy execution should succeed");
        assert_eq!(result.host_output, "[65, 66, 67, 68]");
        assert_eq!(result.impl_output, "[65, 66, 67, 68]");
        assert!(result.host_parity);
    }

    #[test]
    fn execute_strlen_case_hardened_handles_unterminated() {
        let inputs = serde_json::json!({
            "s": [70, 79, 79]
        });
        let result = execute_fixture_case("strlen", &inputs, "hardened")
            .expect("strlen execution should succeed");
        assert_eq!(result.host_output, "UB");
        assert_eq!(result.impl_output, "3");
        assert!(!result.host_parity);
    }

    #[test]
    fn execute_iconv_case_strict_success() {
        let inputs = serde_json::json!({
            "tocode": "UTF-16LE",
            "fromcode": "UTF-8",
            "input": [65, 66],
            "out_len": 8
        });
        let result = execute_fixture_case("iconv", &inputs, "strict")
            .expect("iconv execution should succeed");
        assert_eq!(
            result.impl_output,
            "ok nonrev=0 in_left=0 out_left=4 out=[65, 0, 66, 0]"
        );
    }

    #[test]
    fn execute_iconv_case_strict_e2big() {
        let inputs = serde_json::json!({
            "tocode": "UTF-16LE",
            "fromcode": "UTF-8",
            "input": [65, 66],
            "out_len": 3
        });
        let result = execute_fixture_case("iconv", &inputs, "strict")
            .expect("iconv execution should succeed");
        assert_eq!(
            result.impl_output,
            "err errno=7 in_left=1 out_left=1 out=[65, 0]"
        );
    }

    #[test]
    fn execute_iconv_case_unsupported_encoding() {
        let inputs = serde_json::json!({
            "tocode": "UTF-32",
            "fromcode": "UTF-8",
            "input": [65],
            "out_len": 8
        });
        let result = execute_fixture_case("iconv", &inputs, "strict")
            .expect("iconv execution should succeed");
        assert_eq!(result.impl_output, "open_err errno=22");
    }
}
