//! Conformance and parity tooling for glibc_rust.

use std::ffi::c_void;

use serde::{Deserialize, Serialize};

/// Serialized artifact generated by the traceability builder.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TraceabilityArtifact {
    /// Markdown report suitable for humans.
    pub markdown: String,
    /// JSON report suitable for tooling.
    pub json: String,
}

/// Build traceability artifact for the membrane bootstrap phase.
#[must_use]
pub fn build_traceability_artifact() -> TraceabilityArtifact {
    #[cfg(feature = "asupersync-tooling")]
    {
        use asupersync_conformance::TraceabilityMatrixBuilder;

        let mut matrix = TraceabilityMatrixBuilder::new()
            .requirement_with_category(
                "TSM-1",
                "Memcpy-like operations enforce bounds-aware repair",
                "safety",
            )
            .requirement_with_category(
                "TSM-2",
                "Temporal invalid states must deny or repair deterministically",
                "safety",
            )
            .test(
                "TSM-1",
                "decide_copy_repairs_when_exceeding_known_bounds",
                "crates/glibc_rust/src/safety/membrane.rs",
                1,
            )
            .test(
                "TSM-2",
                "decide_copy_denies_when_pointer_non_live",
                "crates/glibc_rust/src/safety/membrane.rs",
                1,
            )
            .build();

        let markdown = matrix.to_markdown();
        let json = match matrix.to_json() {
            Ok(value) => value,
            Err(error) => format!(r#"{{"error":"{error}"}}"#),
        };

        TraceabilityArtifact { markdown, json }
    }

    #[cfg(not(feature = "asupersync-tooling"))]
    {
        TraceabilityArtifact {
            markdown: String::from("# Traceability\n\nBuild without asupersync-tooling feature."),
            json: String::from("{}"),
        }
    }
}

/// Render a textual diff report for expected vs actual output.
#[must_use]
pub fn render_diff_report(expected: &str, actual: &str) -> String {
    #[cfg(feature = "frankentui-ui")]
    {
        return ftui_harness::diff_text(expected, actual);
    }

    #[cfg(not(feature = "frankentui-ui"))]
    {
        if expected == actual {
            return String::from("no-diff");
        }

        format!(
            "expected:\n{expected}\n\nactual:\n{actual}\n\n(note: enable frankentui-ui for rich diffs)"
        )
    }
}

/// Fixture set captured from host libc behavior.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MemcpyFixtureSet {
    /// Schema/version marker.
    pub suite_version: String,
    /// UTC timestamp string.
    pub captured_at_utc: String,
    /// Captured test cases.
    pub cases: Vec<MemcpyCase>,
}

/// Single memcpy test fixture case.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MemcpyCase {
    /// Case identifier.
    pub name: String,
    /// Input source bytes.
    pub src: Vec<u8>,
    /// Initial destination length.
    pub dst_len: usize,
    /// Requested copy length.
    pub requested_len: usize,
    /// Host libc output destination bytes.
    pub expected_dst: Vec<u8>,
}

/// Per-case verification output.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct VerificationCaseResult {
    /// Case identifier.
    pub name: String,
    /// Expected destination bytes.
    pub expected_dst: Vec<u8>,
    /// Actual destination bytes from glibc_rust.
    pub actual_dst: Vec<u8>,
    /// Whether this case passed.
    pub passed: bool,
}

/// Aggregate verification report.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct VerificationReport {
    /// Number of passing cases.
    pub passed: usize,
    /// Number of failing cases.
    pub failed: usize,
    /// Individual case results.
    pub cases: Vec<VerificationCaseResult>,
}

/// Capture baseline memcpy behavior from host libc for safe test vectors.
#[must_use]
pub fn capture_memcpy_fixture_set() -> MemcpyFixtureSet {
    let template_cases: [(&str, &[u8], usize, usize); 4] = [
        ("copy_full", b"ABCDEFGH", 8, 8),
        ("copy_partial", b"ABCDEFGH", 8, 4),
        ("copy_zero", b"ABCDEFGH", 8, 0),
        ("copy_single", b"ABCDEFGH", 8, 1),
    ];

    let cases = template_cases
        .into_iter()
        .map(|(name, src, dst_len, requested_len)| MemcpyCase {
            name: name.to_string(),
            src: src.to_vec(),
            dst_len,
            requested_len,
            expected_dst: run_host_memcpy(src, dst_len, requested_len),
        })
        .collect();

    MemcpyFixtureSet {
        suite_version: String::from("memcpy-v1"),
        captured_at_utc: String::from("1970-01-01T00:00:00Z"),
        cases,
    }
}

/// Verify fixture set against current glibc_rust preview memcpy entrypoint.
#[must_use]
pub fn verify_memcpy_fixture_set(fixture: &MemcpyFixtureSet) -> VerificationReport {
    let cases: Vec<VerificationCaseResult> = fixture
        .cases
        .iter()
        .map(|case| {
            let mut dst = vec![0_u8; case.dst_len];
            // SAFETY: Case vectors are intentionally valid and bounded.
            unsafe {
                glibc_rust::glibc_rust_memcpy_preview(
                    dst.as_mut_ptr().cast::<c_void>(),
                    case.src.as_ptr().cast::<c_void>(),
                    case.requested_len,
                );
            }

            let passed = dst == case.expected_dst;
            VerificationCaseResult {
                name: case.name.clone(),
                expected_dst: case.expected_dst.clone(),
                actual_dst: dst,
                passed,
            }
        })
        .collect();

    let passed = cases.iter().filter(|case| case.passed).count();
    let failed = cases.len().saturating_sub(passed);

    VerificationReport {
        passed,
        failed,
        cases,
    }
}

/// Render verification report as markdown.
#[must_use]
pub fn render_verification_markdown(report: &VerificationReport) -> String {
    let mut output = String::new();
    output.push_str("# glibc_rust memcpy verification\n\n");
    output.push_str(&format!("- passed: {}\n", report.passed));
    output.push_str(&format!("- failed: {}\n\n", report.failed));
    output.push_str("| case | status |\n");
    output.push_str("|---|---|\n");

    for case in &report.cases {
        let status = if case.passed { "PASS" } else { "FAIL" };
        output.push_str(&format!("| {} | {} |\n", case.name, status));
    }

    output
}

fn run_host_memcpy(src: &[u8], dst_len: usize, requested_len: usize) -> Vec<u8> {
    let mut dst = vec![0_u8; dst_len];
    let effective_len = requested_len.min(src.len()).min(dst.len());

    if effective_len > 0 {
        // SAFETY: We enforce bounded copy length and non-null valid pointers.
        unsafe {
            libc::memcpy(
                dst.as_mut_ptr().cast::<c_void>(),
                src.as_ptr().cast::<c_void>(),
                effective_len,
            );
        }
    }

    dst
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn artifact_contains_content() {
        let artifact = build_traceability_artifact();
        assert!(!artifact.markdown.is_empty());
        assert!(!artifact.json.is_empty());
    }

    #[test]
    fn fallback_diff_marks_no_diff() {
        let report = render_diff_report("same", "same");
        assert!(report.contains("no-diff") || report.contains("same"));
    }

    #[test]
    fn capture_and_verify_memcpy_fixture_set() {
        let fixture = capture_memcpy_fixture_set();
        let report = verify_memcpy_fixture_set(&fixture);
        assert_eq!(report.failed, 0);
        assert_eq!(report.passed, fixture.cases.len());
    }
}
