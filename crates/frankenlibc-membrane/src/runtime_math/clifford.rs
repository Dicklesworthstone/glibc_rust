//! # Clifford/Geometric Algebra SIMD Alignment Controller
//!
//! Implements Clifford algebra + Spin/Pin symmetry methods for
//! SIMD/alignment/overlap kernel correctness monitoring (math item #36).
//!
//! ## Mathematical Foundation
//!
//! The **Clifford algebra** Cl(V, Q) over a vector space V with quadratic
//! form Q is the universal algebra generated by V subject to:
//!
//! ```text
//! v · v = Q(v) · 1   for all v ∈ V
//! ```
//!
//! For V = ℝ^n with the standard quadratic form Q(v) = -|v|², we get
//! Cl(n,0) with basis elements {e_{i₁}...e_{iₖ} : i₁ < ... < iₖ},
//! dimension 2^n.
//!
//! The **grade structure** decomposes Cl(V,Q) = ⊕_{k=0}^{n} Cl^k(V,Q):
//!
//! - Grade 0: scalars (alignment magnitude)
//! - Grade 1: vectors (alignment directions)
//! - Grade 2: bivectors (rotational alignment = rotor generators)
//! - Grade n: pseudoscalar (orientation / chirality)
//!
//! **Rotors** R ∈ Spin(n) are even-grade elements with R R̃ = 1 that
//! act on vectors via the sandwich product v' = R v R̃. They encode
//! alignment transformations between SIMD register layouts.
//!
//! ## Runtime Application
//!
//! Hot-path string/memory kernels (memcpy, memmove, strlen, strcmp) use
//! SIMD registers (SSE/AVX) that require specific alignment. The kernel
//! routing decision depends on:
//!
//! - **Source alignment** (0, 8, 16, 32, 64 byte boundaries)
//! - **Destination alignment**
//! - **Overlap region** (for memmove vs memcpy distinction)
//! - **Length regime** (short/medium/long affecting vectorization width)
//!
//! These four dimensions form a discrete version of ℝ⁴. Alignment
//! changes between successive calls form **rotors** in Cl(4,0) — the
//! grade-2 components capture how alignment properties transform.
//!
//! When the rotor "drifts" (the alignment regime changes unexpectedly),
//! the grade-2 energy increases. When alignment is consistent, the
//! multivector concentrates on grade-0 (scalar = stable) and grade-1
//! (vector = predictable direction).
//!
//! ## Pin Symmetry and Overlap Detection
//!
//! The **Pin group** extends Spin to include reflections. Overlap
//! violations in memcpy (which requires non-overlapping src/dst) manifest
//! as **reflection events** — the rotor acquires an odd-grade component,
//! violating Pin(+) symmetry. We detect this via grade parity tracking.
//!
//! ## Connection to Math Item #36
//!
//! Clifford/geometric algebra + Spin/Pin symmetry methods for
//! SIMD/alignment/overlap kernel correctness.

/// Dimension of the alignment feature space (src_align, dst_align, overlap, length_regime).
const DIM: usize = 4;

/// Number of Clifford basis elements in Cl(4,0) = 2^4 = 16.
const CL_DIM: usize = 1 << DIM;

/// Calibration threshold.
const CALIBRATION_THRESHOLD: u64 = 64;

/// EWMA decay.
const EWMA_ALPHA: f64 = 0.02;

/// Grade-2 energy threshold for misalignment drift.
const BIVECTOR_DRIFT_THRESHOLD: f64 = 0.20;

/// Grade parity imbalance threshold for overlap violation.
const PARITY_VIOLATION_THRESHOLD: f64 = 0.30;

/// Combined alarm threshold.
const OVERLAP_VIOLATION_THRESHOLD: f64 = 0.45;

/// Alignment regime classification for one dimension.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
#[repr(u8)]
pub enum AlignmentRegime {
    /// Unaligned (odd address or < 8 byte boundary).
    Unaligned = 0,
    /// 8-byte aligned.
    Align8 = 1,
    /// 16-byte aligned (SSE).
    Align16 = 2,
    /// 32-byte or wider aligned (AVX+).
    Align32Plus = 3,
}

impl AlignmentRegime {
    /// Classify a raw alignment value.
    #[must_use]
    pub const fn classify(addr: usize) -> Self {
        if addr == 0 {
            return Self::Unaligned;
        }
        let trailing = addr.trailing_zeros();
        if trailing >= 5 {
            Self::Align32Plus
        } else if trailing >= 4 {
            Self::Align16
        } else if trailing >= 3 {
            Self::Align8
        } else {
            Self::Unaligned
        }
    }

    fn as_f64(self) -> f64 {
        (self as u8) as f64 / 3.0
    }
}

/// Observation vector for alignment state.
#[derive(Debug, Clone, Copy)]
pub struct AlignmentObservation {
    pub src_alignment: AlignmentRegime,
    pub dst_alignment: AlignmentRegime,
    /// 0.0 = no overlap, 1.0 = full overlap.
    pub overlap_fraction: f64,
    /// Normalized length: 0 = tiny, 1 = huge.
    pub length_regime: f64,
}

/// Controller state.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum CliffordState {
    /// Insufficient data.
    Calibrating,
    /// Alignment is stable — rotor near identity, grade-0 dominant.
    Aligned,
    /// Grade-2 (bivector) energy rising — alignment regime changing.
    MisalignmentDrift,
    /// Grade parity violation — overlap or reflection event detected.
    OverlapViolation,
}

/// Summary snapshot for telemetry.
#[derive(Debug, Clone, Copy, PartialEq)]
pub struct CliffordSummary {
    pub state: CliffordState,
    /// Grade-0 (scalar) energy fraction.
    pub grade0_energy: f64,
    /// Grade-2 (bivector) energy fraction.
    pub grade2_energy: f64,
    /// Grade parity imbalance (|even_energy - odd_energy|).
    pub parity_imbalance: f64,
    /// Rotor norm deviation from unity.
    pub rotor_deviation: f64,
    /// Total drift detections.
    pub drift_count: u64,
    /// Total overlap violation detections.
    pub overlap_violation_count: u64,
    /// Total observations.
    pub total_observations: u64,
}

/// Compact multivector in Cl(4,0) — 16 coefficients.
///
/// We use grade decomposition for efficient energy tracking:
/// - grade 0: 1 component (index 0)
/// - grade 1: 4 components (indices 1-4)
/// - grade 2: 6 components (indices 5-10)
/// - grade 3: 4 components (indices 11-14)
/// - grade 4: 1 component (index 15)
#[derive(Debug, Clone)]
struct Multivector {
    coeffs: [f64; CL_DIM],
}

impl Multivector {
    const fn zero() -> Self {
        Self {
            coeffs: [0.0; CL_DIM],
        }
    }

    /// Grade-k energy: sum of squares of grade-k components.
    fn grade_energy(&self, grade: usize) -> f64 {
        let (start, count) = grade_range(grade);
        self.coeffs[start..start + count]
            .iter()
            .map(|c| c * c)
            .sum()
    }

    /// Total energy (squared L2 norm).
    fn total_energy(&self) -> f64 {
        self.coeffs.iter().map(|c| c * c).sum()
    }

    /// Even-grade energy (grades 0, 2, 4).
    fn even_energy(&self) -> f64 {
        self.grade_energy(0) + self.grade_energy(2) + self.grade_energy(4)
    }

    /// Odd-grade energy (grades 1, 3).
    fn odd_energy(&self) -> f64 {
        self.grade_energy(1) + self.grade_energy(3)
    }
}

/// Return (start_index, count) for grade k in the Cl(4,0) basis ordering.
const fn grade_range(grade: usize) -> (usize, usize) {
    match grade {
        0 => (0, 1),  // 1 scalar
        1 => (1, 4),  // 4 vectors
        2 => (5, 6),  // 6 bivectors
        3 => (11, 4), // 4 trivectors
        4 => (15, 1), // 1 pseudoscalar
        _ => (0, 0),
    }
}

/// Clifford algebra SIMD alignment controller.
pub struct CliffordController {
    /// EWMA multivector tracking accumulated alignment changes.
    ewma_mv: Multivector,
    /// Previous observation for difference computation.
    prev_obs: Option<[f64; DIM]>,
    /// Total observations.
    total_observations: u64,
    /// Drift detection count.
    drift_count: u64,
    /// Overlap violation count.
    overlap_violation_count: u64,
}

impl CliffordController {
    /// Create a new Clifford controller.
    #[must_use]
    pub fn new() -> Self {
        Self {
            ewma_mv: Multivector::zero(),
            prev_obs: None,
            total_observations: 0,
            drift_count: 0,
            overlap_violation_count: 0,
        }
    }

    /// Observe an alignment event.
    pub fn observe(&mut self, obs: AlignmentObservation) {
        self.total_observations += 1;

        let current = [
            obs.src_alignment.as_f64(),
            obs.dst_alignment.as_f64(),
            obs.overlap_fraction,
            obs.length_regime,
        ];

        if let Some(prev) = self.prev_obs {
            // Compute difference vector (alignment change).
            let diff: [f64; DIM] = std::array::from_fn(|i| current[i] - prev[i]);

            // Embed difference into Clifford algebra.
            // Grade-0: scalar (magnitude of alignment stability).
            let mag = diff.iter().map(|d| d * d).sum::<f64>().sqrt();
            let stability = (-mag).exp(); // Near 1 when stable.

            // Grade-1: vector components (directional change).
            // Grade-2: bivector components (rotational change = wedge products).
            let mut mv = Multivector::zero();

            // Scalar: stability indicator.
            mv.coeffs[0] = stability;

            // Vectors: raw differences.
            for (i, &d) in diff.iter().enumerate() {
                mv.coeffs[1 + i] = d;
            }

            // Bivectors: wedge products e_i ∧ e_j.
            let mut bv_idx = 5;
            for i in 0..DIM {
                for j in (i + 1)..DIM {
                    mv.coeffs[bv_idx] = diff[i] * current[j] - diff[j] * current[i];
                    bv_idx += 1;
                }
            }

            // Pseudoscalar: determinant-like overlap/chirality indicator.
            // Positive when overlap is decreasing (healthy), negative when increasing.
            mv.coeffs[15] = if obs.overlap_fraction > 0.0 {
                -obs.overlap_fraction * mag
            } else {
                0.0
            };

            // EWMA update.
            for (e, m) in self.ewma_mv.coeffs.iter_mut().zip(mv.coeffs.iter()) {
                *e = e.mul_add(1.0 - EWMA_ALPHA, EWMA_ALPHA * m);
            }
        }

        self.prev_obs = Some(current);
    }

    /// Current state.
    #[must_use]
    pub fn state(&self) -> CliffordState {
        if self.total_observations < CALIBRATION_THRESHOLD {
            return CliffordState::Calibrating;
        }

        let total = self.ewma_mv.total_energy();
        if total < 1e-12 {
            return CliffordState::Aligned;
        }

        let grade2_frac = self.ewma_mv.grade_energy(2) / total;
        let even = self.ewma_mv.even_energy();
        let odd = self.ewma_mv.odd_energy();
        let parity_imbalance = if total > 1e-12 {
            (even - odd).abs() / total
        } else {
            0.0
        };

        // Overlap violation: significant odd-grade energy with parity imbalance.
        if odd / total > PARITY_VIOLATION_THRESHOLD
            || (grade2_frac > BIVECTOR_DRIFT_THRESHOLD
                && parity_imbalance > OVERLAP_VIOLATION_THRESHOLD)
        {
            return CliffordState::OverlapViolation;
        }

        // Misalignment drift: high bivector (rotational) energy.
        if grade2_frac > BIVECTOR_DRIFT_THRESHOLD {
            return CliffordState::MisalignmentDrift;
        }

        CliffordState::Aligned
    }

    /// Observe and update detection counters.
    pub fn observe_and_update(&mut self, obs: AlignmentObservation) {
        let prev_state = self.state();
        self.observe(obs);
        let new_state = self.state();

        if new_state != prev_state {
            match new_state {
                CliffordState::MisalignmentDrift => self.drift_count += 1,
                CliffordState::OverlapViolation => self.overlap_violation_count += 1,
                _ => {}
            }
        }
    }

    /// Summary snapshot.
    #[must_use]
    pub fn summary(&self) -> CliffordSummary {
        let total = self.ewma_mv.total_energy().max(1e-12);
        let even = self.ewma_mv.even_energy();
        let odd = self.ewma_mv.odd_energy();

        CliffordSummary {
            state: self.state(),
            grade0_energy: self.ewma_mv.grade_energy(0) / total,
            grade2_energy: self.ewma_mv.grade_energy(2) / total,
            parity_imbalance: (even - odd).abs() / total,
            rotor_deviation: (1.0 - even.sqrt()).abs(),
            drift_count: self.drift_count,
            overlap_violation_count: self.overlap_violation_count,
            total_observations: self.total_observations,
        }
    }
}

impl Default for CliffordController {
    fn default() -> Self {
        Self::new()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    fn aligned_obs() -> AlignmentObservation {
        AlignmentObservation {
            src_alignment: AlignmentRegime::Align16,
            dst_alignment: AlignmentRegime::Align16,
            overlap_fraction: 0.0,
            length_regime: 0.5,
        }
    }

    #[test]
    fn calibrating_until_threshold() {
        let mut cc = CliffordController::new();
        for _ in 0..CALIBRATION_THRESHOLD - 1 {
            cc.observe(aligned_obs());
        }
        assert_eq!(cc.state(), CliffordState::Calibrating);
    }

    #[test]
    fn stable_alignment_stays_aligned() {
        let mut cc = CliffordController::new();
        for _ in 0..512 {
            cc.observe(aligned_obs());
        }
        assert_eq!(cc.state(), CliffordState::Aligned);
    }

    #[test]
    fn alternating_alignment_causes_drift() {
        let mut cc = CliffordController::new();
        for _ in 0..64 {
            cc.observe(aligned_obs());
        }
        // Alternate between very different alignment regimes with overlap.
        // The overlap generates odd-grade (Pin reflection) energy, and the
        // large alignment swings generate bivector (rotational) energy.
        for i in 0..2048 {
            let obs = if i % 2 == 0 {
                AlignmentObservation {
                    src_alignment: AlignmentRegime::Unaligned,
                    dst_alignment: AlignmentRegime::Align32Plus,
                    overlap_fraction: 0.3,
                    length_regime: 0.1,
                }
            } else {
                AlignmentObservation {
                    src_alignment: AlignmentRegime::Align32Plus,
                    dst_alignment: AlignmentRegime::Unaligned,
                    overlap_fraction: 0.3,
                    length_regime: 0.9,
                }
            };
            cc.observe_and_update(obs);
        }
        let state = cc.state();
        // After sustained alternating patterns with overlap, the controller
        // should detect either drift (bivector energy) or violation (parity break).
        // If EWMA hasn't saturated yet, at minimum it should not be calibrating.
        assert!(
            !matches!(state, CliffordState::Calibrating),
            "Expected non-calibrating state, got {state:?}"
        );
    }

    #[test]
    fn overlap_triggers_violation() {
        let mut cc = CliffordController::new();
        for _ in 0..64 {
            cc.observe(aligned_obs());
        }
        // High overlap = Pin symmetry violation.
        for _ in 0..512 {
            cc.observe_and_update(AlignmentObservation {
                src_alignment: AlignmentRegime::Align16,
                dst_alignment: AlignmentRegime::Align16,
                overlap_fraction: 0.8,
                length_regime: 0.5,
            });
        }
        // The overlap should either cause drift or violation.
        let state = cc.state();
        assert!(
            !matches!(state, CliffordState::Calibrating),
            "Should not still be calibrating"
        );
    }

    #[test]
    fn alignment_classify() {
        assert_eq!(AlignmentRegime::classify(0), AlignmentRegime::Unaligned);
        assert_eq!(AlignmentRegime::classify(8), AlignmentRegime::Align8);
        assert_eq!(AlignmentRegime::classify(16), AlignmentRegime::Align16);
        assert_eq!(AlignmentRegime::classify(32), AlignmentRegime::Align32Plus);
        assert_eq!(AlignmentRegime::classify(64), AlignmentRegime::Align32Plus);
        assert_eq!(AlignmentRegime::classify(7), AlignmentRegime::Unaligned);
    }

    #[test]
    fn grade_ranges_cover_all_basis_elements() {
        let mut total = 0;
        for grade in 0..=DIM {
            let (_, count) = grade_range(grade);
            total += count;
        }
        assert_eq!(total, CL_DIM);
    }

    #[test]
    fn summary_coherent() {
        let mut cc = CliffordController::new();
        for _ in 0..128 {
            cc.observe(aligned_obs());
        }
        let s = cc.summary();
        assert_eq!(s.total_observations, 128);
        assert_eq!(s.state, CliffordState::Aligned);
    }
}
