# Proof-Carrying Policy Tables (Design)

Bead: `bd-2dz`

Goal: move complex hardened decision synthesis (SMT/CHC/CEGAR/POMDP) offline and ship a
tiny deterministic runtime artifact (table + hash + certificate metadata) that can be
verified cheaply and consulted in O(1) time.

This is a design-only document. Implementation is expected to land in `bd-20s` (loader +
hash verifier) and `bd-3kh` (integration into `RuntimeMathKernel`).

## Constraints (Non-Negotiable)

- Runtime libc must be deterministic, allocation-free on hot paths, and budgeted:
  - strict fast path overhead target: <20ns
  - hardened overhead target: <200ns
- Strict mode must not pay codec/proof costs on the hot path.
- No runtime dependency on `/dp/asupersync` or `/dp/frankentui` (tooling only).
- Failure must be conservative:
  - if an artifact is missing/invalid, fall back to built-in policy that is safe and ABI-compatible.

## Terminology

- **Key**: a discretized runtime context used to index the table.
- **Cell**: the table entry for a key; contains recommended policy decisions.
- **Certificate metadata**: compact evidence that the table was generated by an offline
  pipeline and satisfies invariants; runtime verifies only cheap invariants + hashes.

## What This Replaces

Today `RuntimeMathKernel::decide(...)` is a hand-coded merge of multiple online kernels
producing a final `(profile, action)` decision.

Policy tables introduce an additional *offline-synthesized* layer that:
- can encode hard constraints (monotonicity, mode refinement, family caps),
- can be diffed/versioned as a data artifact,
- provides a stable contract for drift-control and reproducibility.

## Artifact Format (Binary)

File extension: `.pcpt` (proof-carrying policy table)

### Header (Fixed-Size, Little-Endian)

- `magic[8] = b\"PCPTv001\"`
- `schema_version: u16`
- `hash_alg: u8`
  - 1 = BLAKE3-256 (preferred)
  - 2 = SHA-256 (fallback)
- `key_spec_id: u16`
  - identifies the exact bucketing/key encoding contract (see Key Spec below)
- `cell_spec_id: u16`
  - identifies the exact cell encoding contract
- `table_len: u32`
  - number of cells
- `table_bytes: u32`
  - byte length of the cell array
- `table_hash[32]`
  - hash over the cell array bytes only (not header)
- `meta_hash[32]`
  - hash over the certificate metadata section
- `reserved[32]` (must be zero)

Rationale:
- `key_spec_id`/`cell_spec_id` allow additive evolution without ambiguity.
- hashing the table and metadata separately makes diffs and partial validation easier.

### Cell Array

Contiguous `table_len` fixed-size cells.

Suggested cell layout (4 bytes):
- `profile: u8` (0=Fast, 1=Full)
- `action: u8` (0=Allow, 1=FullValidate, 2=Repair, 3=Deny)
- `repair: u8` (0=None, else `HealingAction` compact ID)
- `flags: u8`
  - bit0: strict_allowed (must be 1 for strict rows)
  - bit1: hardened_only (row only valid in hardened mode)
  - bit2: requires_barrier_ok (cell assumes admissible barrier)
  - remaining reserved

Notes:
- The runtime must treat any unknown enum value as invalid and fall back conservatively.
- `repair` is interpreted only when `action=Repair`.

### Certificate Metadata (TLV)

The certificate metadata is a TLV stream:
- `type: u16`
- `len: u16`
- `value[len]`

Minimum required TLVs:
- `0x0001` Generator build info (ASCII, truncated)
- `0x0002` Offline proof digest (32 bytes, e.g., hash of SMT/CHC transcript bundle)
- `0x0003` Invariant manifest (ASCII list of checked invariants + versions)

Optional TLVs:
- `0x0100` Merkle root of per-row proof digests (for sampled row checks)
- `0x0101` Row digest array (for tiny tables only)

Runtime behavior:
- TLVs are carried through to evidence logs and harness reporting.
- Runtime does not attempt to validate SMT proofs; it validates hashes + cheap invariants.

## Key Spec (Bucketing + Indexing)

We require O(1) indexing and a small table.

Key dimensions (first pass, deterministic):

1. `mode` (2): strict vs hardened
2. `family` (ApiFamily::COUNT)
3. `risk_bucket` (16): bucketize `risk_upper_bound_ppm` (0..=1_000_000)
4. `budget_bucket` (8): derived from (fast_over_budget, full_over_budget, pareto_exhausted)
5. `consistency_bucket` (4): bucketize `consistency_faults` (0, 1, 2-3, >=4)

Total rows (current ApiFamily::COUNT=20):
- `2 * 20 * 16 * 8 * 4 = 20_480` cells
- at 4 bytes/cell: ~80KB table (acceptable; cache-hot)

Uniform bucketization (runtime cheap):
- `risk_bucket = min(15, risk_ppm / 62_500)`  (16 equal-width bins)

Budget bucketization:
- `fast_over_budget` in {0,1}
- `full_over_budget` in {0,1}
- `pareto_exhausted` in {0,1}
- `budget_bucket = fast_over_budget | (full_over_budget<<1) | (pareto_exhausted<<2)`

Consistency bucketization:
- `0 -> 0`
- `1 -> 1`
- `2..=3 -> 2`
- `>=4 -> 3`

Index formula (row-major):

```
idx =
  ((((mode * F + family) * R + risk_bucket) * B + budget_bucket) * C + consistency_bucket)
```

with:
- `F = ApiFamily::COUNT`
- `R = 16`, `B = 8`, `C = 4`

This is integer-only and branch-light.

## Runtime Verification Contract

Runtime verification occurs once at init (or first use) and must be bounded:

1. Header checks:
   - magic, schema_version, key_spec_id, cell_spec_id recognized
   - reserved bytes are zero
2. Hash checks:
   - recompute `table_hash` over cell array
   - recompute `meta_hash` over TLV section
3. Cell sanity checks (single pass over all cells):
   - enum values in range
   - strict rows never set `action=Repair`
   - if `action=Deny`, `repair` must be None
4. Cheap lattice invariants (single pass, no allocations):
   - **risk monotonicity** per (mode,family,budget,consistency):
     - higher `risk_bucket` must not reduce `profile` (Fast -> Full) or weaken `action`.
   - **mode refinement**:
     - strict must be at least as permissive as hardened for *defined* behavior, but must
       not introduce repairs; any discrepancy must be explicitly marked via flags.

If any check fails:
- disable artifact usage for the process
- fall back to built-in policy (current handwritten controller)
- record an evidence event via commitment audit / metrics

## Integration Point (Runtime)

Integration is intentionally late in `RuntimeMathKernel::decide(...)`:

1. Compute existing decision `base` using online kernels.
2. If policy table is present + verified:
   - compute key (integer-only)
   - load cell (single bounds check)
   - merge conservatively:
     - `profile_final = max(base.profile, cell.profile)`
     - `action_final = conservative_join(base.action, cell.action, mode)`
       - strict: disallow `Repair` regardless of cell
       - hardened: allow Repair but never override a base Deny
3. Return final decision + `policy_id` derived from the merged values.

Conservative join (total order by restrictiveness, per mode):

Strict: `Allow < FullValidate < Deny`
Hardened: `Allow < FullValidate < Repair < Deny`

This makes the table safe to use as an override without creating unsafe downgrades.

## Offline Synthesis / Proof Story (Tooling)

Offline generation produces:
- `.pcpt` artifact (table + metadata)
- proof bundle (SMT/CHC/CEGAR logs) stored in tooling outputs

Mandatory offline checks (examples):
- CHC/CEGAR: prove monotonicity and mode refinement constraints for the discrete table.
- SMT refinement: prove table decisions refine a spec-level safety policy (strict/hardened).
- Conformal/e-process: calibrate bucket boundaries / penalties so false escalation rates are controlled.

The runtime artifact carries only:
- hashes + proof digest + manifest of invariants checked and tool versions.

Tooling integration points:
- `glibc-rs-harness` verifies artifacts during CI and renders diffs with FrankentUI.
- `/dp/asupersync` orchestrates deterministic proof runs and attaches traceability metadata.

## Legacy Anchors (Grounding)

The policy table must be interpretable as defending concrete legacy surfaces:
- Allocator (`malloc/free/realloc`): temporal/provenance corruption -> quarantine depth + deny/repair.
- Loader (`dlopen/dlsym`): compatibility drift -> deny/force full validation.
- String/memory hot paths: overlap/alignment -> full validation routing.
- Threading (`pthread_*`): cancellation/race surfaces -> stricter barrier gating.
- IO/Socket/Resolver: poisoning/retry instability -> budget-aware escalation.

Each key dimension is justified by these anchors (risk, budget pressure, consistency faults).

