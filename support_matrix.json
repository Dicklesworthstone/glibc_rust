{
  "version": 2,
  "generated_at_utc": "2026-02-13T18:07:59Z",
  "library": "/data/tmp/cargo-target/release/libfrankenlibc_abi.so",
  "total_exported": 250,
  "taxonomy": {
    "Implemented": "Native Rust code owns the entire operation. No host libc dependency. Full test coverage required.",
    "RawSyscall": "ABI entrypoint marshals arguments directly to Linux syscall instruction. No glibc call-through.",
    "GlibcCallThrough": "Delegates to host glibc after membrane pre/post validation. Requires host libc at runtime.",
    "Stub": "Deterministic failure contract. Returns stable errno/error code. Documented in support policy.",
    "perf_classes": {
      "strict_hotpath": "Called >= 1M/sec in typical workloads. Must meet <20ns strict budget.",
      "hardened_hotpath": "Called >= 1M/sec in hardened mode. Must meet <200ns hardened budget.",
      "coldpath": "Called < 1K/sec. No latency budget enforced."
    },
    "default_policy": "Any exported symbol absent from explicit classification defaults to Stub and causes drift failure (exit 3).",
    "mode_contract": {
      "strict": "POSIX-correct error semantics. Membrane validates but never silently rewrites. ABI-compatible.",
      "hardened": "TSM repair enabled. Membrane applies deterministic healing (clamp, truncate, safe-default). Logs HealingAction."
    },
    "artifact_applicability": {
      "Interpose": [
        "Implemented",
        "RawSyscall",
        "GlibcCallThrough",
        "Stub"
      ],
      "Replace": [
        "Implemented",
        "RawSyscall"
      ],
      "rule": "Implemented+RawSyscall apply to both artifacts; GlibcCallThrough+Stub are Interpose-only."
    }
  },
  "symbols": [
    {
      "symbol": "__errno_location",
      "status": "Implemented",
      "module": "errno_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Thread-local errno via Rust; ABI-compatible __errno_location pointer",
      "hardened_semantics": "Thread-local errno; no mode difference (stateless query)",
      "default_stub": false
    },
    {
      "symbol": "__frankenlibc_startup_phase0",
      "status": "Implemented",
      "module": "startup_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Phase-0 startup skeleton for controlled fixtures; validates argc/argv/envp and captures auxv/secure-mode invariants",
      "hardened_semantics": "Phase-0 startup with hardened membrane routing; deterministic startup invariant capture for fixture binaries",
      "default_stub": false
    },
    {
      "symbol": "__frankenlibc_startup_snapshot",
      "status": "Implemented",
      "module": "startup_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Phase-0 startup skeleton for controlled fixtures; validates argc/argv/envp and captures auxv/secure-mode invariants",
      "hardened_semantics": "Phase-0 startup with hardened membrane routing; deterministic startup invariant capture for fixture binaries",
      "default_stub": false
    },
    {
      "symbol": "__libc_start_main",
      "status": "Implemented",
      "module": "startup_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Phase-0 startup skeleton for controlled fixtures; validates argc/argv/envp and captures auxv/secure-mode invariants",
      "hardened_semantics": "Phase-0 startup with hardened membrane routing; deterministic startup invariant capture for fixture binaries",
      "default_stub": false
    },
    {
      "symbol": "_exit",
      "status": "RawSyscall",
      "module": "process_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for process control; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; validates argv/envp pointer arrays before execve",
      "default_stub": false
    },
    {
      "symbol": "accept",
      "status": "RawSyscall",
      "module": "socket_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for BSD sockets; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; clamps send/recv buffer lengths to tracked bounds",
      "default_stub": false
    },
    {
      "symbol": "access",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for POSIX I/O and process queries; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; clamps read/write count to tracked buffer bounds, defaults invalid whence/amode",
      "default_stub": false
    },
    {
      "symbol": "acos",
      "status": "Implemented",
      "module": "math_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Rust std::f64 math; returns NaN/Inf per IEEE 754; no repair",
      "hardened_semantics": "Rust std::f64 math; no mode difference (pure computation)",
      "default_stub": false
    },
    {
      "symbol": "aligned_alloc",
      "status": "Implemented",
      "module": "malloc_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Safe Rust arena allocator; null on failure; double-free silently ignored",
      "hardened_semantics": "Arena with healing: foreign-ptr realloc as malloc, double-free logged as HealingAction",
      "default_stub": false
    },
    {
      "symbol": "asin",
      "status": "Implemented",
      "module": "math_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Rust std::f64 math; returns NaN/Inf per IEEE 754; no repair",
      "hardened_semantics": "Rust std::f64 math; no mode difference (pure computation)",
      "default_stub": false
    },
    {
      "symbol": "atan",
      "status": "Implemented",
      "module": "math_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Rust std::f64 math; returns NaN/Inf per IEEE 754; no repair",
      "hardened_semantics": "Rust std::f64 math; no mode difference (pure computation)",
      "default_stub": false
    },
    {
      "symbol": "atan2",
      "status": "Implemented",
      "module": "math_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Rust std::f64 math; returns NaN/Inf per IEEE 754; no repair",
      "hardened_semantics": "Rust std::f64 math; no mode difference (pure computation)",
      "default_stub": false
    },
    {
      "symbol": "atexit",
      "status": "Implemented",
      "module": "stdlib_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Safe Rust stdlib (atoi/qsort/bsearch); POSIX-correct return values and errno",
      "hardened_semantics": "Stdlib with hardened membrane; repair clamping on comparator bounds",
      "default_stub": false
    },
    {
      "symbol": "atoi",
      "status": "Implemented",
      "module": "stdlib_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Safe Rust stdlib (atoi/qsort/bsearch); POSIX-correct return values and errno",
      "hardened_semantics": "Stdlib with hardened membrane; repair clamping on comparator bounds",
      "default_stub": false
    },
    {
      "symbol": "atol",
      "status": "Implemented",
      "module": "stdlib_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Safe Rust stdlib (atoi/qsort/bsearch); POSIX-correct return values and errno",
      "hardened_semantics": "Stdlib with hardened membrane; repair clamping on comparator bounds",
      "default_stub": false
    },
    {
      "symbol": "bind",
      "status": "RawSyscall",
      "module": "socket_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for BSD sockets; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; clamps send/recv buffer lengths to tracked bounds",
      "default_stub": false
    },
    {
      "symbol": "bsearch",
      "status": "Implemented",
      "module": "stdlib_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Safe Rust stdlib (atoi/qsort/bsearch); POSIX-correct return values and errno",
      "hardened_semantics": "Stdlib with hardened membrane; repair clamping on comparator bounds",
      "default_stub": false
    },
    {
      "symbol": "calloc",
      "status": "Implemented",
      "module": "malloc_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Safe Rust arena allocator; null on failure; double-free silently ignored",
      "hardened_semantics": "Arena with healing: foreign-ptr realloc as malloc, double-free logged as HealingAction",
      "default_stub": false
    },
    {
      "symbol": "ceil",
      "status": "Implemented",
      "module": "math_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Rust std::f64 math; returns NaN/Inf per IEEE 754; no repair",
      "hardened_semantics": "Rust std::f64 math; no mode difference (pure computation)",
      "default_stub": false
    },
    {
      "symbol": "cfgetispeed",
      "status": "RawSyscall",
      "module": "termios_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux ioctl for terminal control; POSIX errno on failure",
      "hardened_semantics": "Raw ioctl; validates termios struct pointer bounds",
      "default_stub": false
    },
    {
      "symbol": "cfgetospeed",
      "status": "RawSyscall",
      "module": "termios_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux ioctl for terminal control; POSIX errno on failure",
      "hardened_semantics": "Raw ioctl; validates termios struct pointer bounds",
      "default_stub": false
    },
    {
      "symbol": "cfsetispeed",
      "status": "RawSyscall",
      "module": "termios_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux ioctl for terminal control; POSIX errno on failure",
      "hardened_semantics": "Raw ioctl; validates termios struct pointer bounds",
      "default_stub": false
    },
    {
      "symbol": "cfsetospeed",
      "status": "RawSyscall",
      "module": "termios_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux ioctl for terminal control; POSIX errno on failure",
      "hardened_semantics": "Raw ioctl; validates termios struct pointer bounds",
      "default_stub": false
    },
    {
      "symbol": "chdir",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for POSIX I/O and process queries; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; clamps read/write count to tracked buffer bounds, defaults invalid whence/amode",
      "default_stub": false
    },
    {
      "symbol": "clearerr",
      "status": "Implemented",
      "module": "stdio_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Native stream-registry + syscall-backed stdio path; no host glibc call-through",
      "hardened_semantics": "Native stream-registry + syscall-backed stdio path with membrane validation/repair; no host glibc call-through",
      "default_stub": false
    },
    {
      "symbol": "clock",
      "status": "RawSyscall",
      "module": "time_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for time queries; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; defaults invalid clock_id to CLOCK_REALTIME",
      "default_stub": false
    },
    {
      "symbol": "clock_gettime",
      "status": "RawSyscall",
      "module": "time_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for time queries; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; defaults invalid clock_id to CLOCK_REALTIME",
      "default_stub": false
    },
    {
      "symbol": "close",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for POSIX I/O and process queries; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; clamps read/write count to tracked buffer bounds, defaults invalid whence/amode",
      "default_stub": false
    },
    {
      "symbol": "closedir",
      "status": "RawSyscall",
      "module": "dirent_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for directory enumeration; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; validates path pointer bounds before getdents64",
      "default_stub": false
    },
    {
      "symbol": "connect",
      "status": "RawSyscall",
      "module": "socket_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for BSD sockets; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; clamps send/recv buffer lengths to tracked bounds",
      "default_stub": false
    },
    {
      "symbol": "cos",
      "status": "Implemented",
      "module": "math_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Rust std::f64 math; returns NaN/Inf per IEEE 754; no repair",
      "hardened_semantics": "Rust std::f64 math; no mode difference (pure computation)",
      "default_stub": false
    },
    {
      "symbol": "dlclose",
      "status": "GlibcCallThrough",
      "module": "dlfcn_abi",
      "perf_class": "coldpath",
      "strict_semantics": "dlfcn boundary policy: host glibc call-through for dlopen/dlsym/dlclose with thread-local dlerror contract",
      "hardened_semantics": "dlfcn boundary policy: invalid dlopen flags heal to RTLD_NOW; null/denied loader inputs return deterministic dlerror",
      "default_stub": false
    },
    {
      "symbol": "dlerror",
      "status": "GlibcCallThrough",
      "module": "dlfcn_abi",
      "perf_class": "coldpath",
      "strict_semantics": "dlfcn boundary policy: host glibc call-through for dlopen/dlsym/dlclose with thread-local dlerror contract",
      "hardened_semantics": "dlfcn boundary policy: invalid dlopen flags heal to RTLD_NOW; null/denied loader inputs return deterministic dlerror",
      "default_stub": false
    },
    {
      "symbol": "dlopen",
      "status": "GlibcCallThrough",
      "module": "dlfcn_abi",
      "perf_class": "coldpath",
      "strict_semantics": "dlfcn boundary policy: host glibc call-through for dlopen/dlsym/dlclose with thread-local dlerror contract",
      "hardened_semantics": "dlfcn boundary policy: invalid dlopen flags heal to RTLD_NOW; null/denied loader inputs return deterministic dlerror",
      "default_stub": false
    },
    {
      "symbol": "dlsym",
      "status": "GlibcCallThrough",
      "module": "dlfcn_abi",
      "perf_class": "coldpath",
      "strict_semantics": "dlfcn boundary policy: host glibc call-through for dlopen/dlsym/dlclose with thread-local dlerror contract",
      "hardened_semantics": "dlfcn boundary policy: invalid dlopen flags heal to RTLD_NOW; null/denied loader inputs return deterministic dlerror",
      "default_stub": false
    },
    {
      "symbol": "dup",
      "status": "RawSyscall",
      "module": "io_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for dup/dup2/pipe/fcntl; POSIX errno on failure",
      "hardened_semantics": "Raw syscall with hardened membrane; repair on invalid flags",
      "default_stub": false
    },
    {
      "symbol": "dup2",
      "status": "RawSyscall",
      "module": "io_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for dup/dup2/pipe/fcntl; POSIX errno on failure",
      "hardened_semantics": "Raw syscall with hardened membrane; repair on invalid flags",
      "default_stub": false
    },
    {
      "symbol": "endgrent",
      "status": "Implemented",
      "module": "grp_abi",
      "perf_class": "coldpath",
      "strict_semantics": "NSS files backend: closes /etc/group enumeration and frees cached data",
      "hardened_semantics": "NSS files backend with membrane validation",
      "default_stub": false
    },
    {
      "symbol": "endpwent",
      "status": "Implemented",
      "module": "pwd_abi",
      "perf_class": "coldpath",
      "strict_semantics": "NSS files backend: closes /etc/passwd enumeration and frees cached data",
      "hardened_semantics": "NSS files backend with membrane validation",
      "default_stub": false
    },
    {
      "symbol": "erf",
      "status": "Implemented",
      "module": "math_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Rust std::f64 math; returns NaN/Inf per IEEE 754; no repair",
      "hardened_semantics": "Rust std::f64 math; no mode difference (pure computation)",
      "default_stub": false
    },
    {
      "symbol": "execve",
      "status": "RawSyscall",
      "module": "process_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for process control; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; validates argv/envp pointer arrays before execve",
      "default_stub": false
    },
    {
      "symbol": "execvp",
      "status": "RawSyscall",
      "module": "process_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for process control; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; validates argv/envp pointer arrays before execve",
      "default_stub": false
    },
    {
      "symbol": "exit",
      "status": "Implemented",
      "module": "stdlib_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Safe Rust stdlib (atoi/qsort/bsearch); POSIX-correct return values and errno",
      "hardened_semantics": "Stdlib with hardened membrane; repair clamping on comparator bounds",
      "default_stub": false
    },
    {
      "symbol": "exp",
      "status": "Implemented",
      "module": "math_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Rust std::f64 math; returns NaN/Inf per IEEE 754; no repair",
      "hardened_semantics": "Rust std::f64 math; no mode difference (pure computation)",
      "default_stub": false
    },
    {
      "symbol": "fabs",
      "status": "Implemented",
      "module": "math_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Rust std::f64 math; returns NaN/Inf per IEEE 754; no repair",
      "hardened_semantics": "Rust std::f64 math; no mode difference (pure computation)",
      "default_stub": false
    },
    {
      "symbol": "fchdir",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for POSIX I/O and process queries; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; clamps read/write count to tracked buffer bounds, defaults invalid whence/amode",
      "default_stub": false
    },
    {
      "symbol": "fclose",
      "status": "GlibcCallThrough",
      "module": "stdio_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Delegates to host glibc FILE* ops after membrane validation; preserves host semantics",
      "hardened_semantics": "Host glibc delegation; hardened membrane bounds C string scans, logs TruncateWithNull",
      "default_stub": false
    },
    {
      "symbol": "fcntl",
      "status": "RawSyscall",
      "module": "io_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for dup/dup2/pipe/fcntl; POSIX errno on failure",
      "hardened_semantics": "Raw syscall with hardened membrane; repair on invalid flags",
      "default_stub": false
    },
    {
      "symbol": "fdatasync",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for POSIX I/O and process queries; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; clamps read/write count to tracked buffer bounds, defaults invalid whence/amode",
      "default_stub": false
    },
    {
      "symbol": "feof",
      "status": "Implemented",
      "module": "stdio_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Native stream-registry + syscall-backed stdio path; no host glibc call-through",
      "hardened_semantics": "Native stream-registry + syscall-backed stdio path with membrane validation/repair; no host glibc call-through",
      "default_stub": false
    },
    {
      "symbol": "ferror",
      "status": "Implemented",
      "module": "stdio_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Native stream-registry + syscall-backed stdio path; no host glibc call-through",
      "hardened_semantics": "Native stream-registry + syscall-backed stdio path with membrane validation/repair; no host glibc call-through",
      "default_stub": false
    },
    {
      "symbol": "fflush",
      "status": "Implemented",
      "module": "stdio_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Native stream-registry + syscall-backed stdio path; no host glibc call-through",
      "hardened_semantics": "Native stream-registry + syscall-backed stdio path with membrane validation/repair; no host glibc call-through",
      "default_stub": false
    },
    {
      "symbol": "fgetc",
      "status": "Implemented",
      "module": "stdio_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Native stream-registry + syscall-backed stdio path; no host glibc call-through",
      "hardened_semantics": "Native stream-registry + syscall-backed stdio path with membrane validation/repair; no host glibc call-through",
      "default_stub": false
    },
    {
      "symbol": "fgets",
      "status": "GlibcCallThrough",
      "module": "stdio_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Delegates to host glibc FILE* ops after membrane validation; preserves host semantics",
      "hardened_semantics": "Host glibc delegation; hardened membrane bounds C string scans, logs TruncateWithNull",
      "default_stub": false
    },
    {
      "symbol": "fileno",
      "status": "Implemented",
      "module": "stdio_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Native stream-registry + syscall-backed stdio path; no host glibc call-through",
      "hardened_semantics": "Native stream-registry + syscall-backed stdio path with membrane validation/repair; no host glibc call-through",
      "default_stub": false
    },
    {
      "symbol": "floor",
      "status": "Implemented",
      "module": "math_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Rust std::f64 math; returns NaN/Inf per IEEE 754; no repair",
      "hardened_semantics": "Rust std::f64 math; no mode difference (pure computation)",
      "default_stub": false
    },
    {
      "symbol": "fmod",
      "status": "Implemented",
      "module": "math_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Rust std::f64 math; returns NaN/Inf per IEEE 754; no repair",
      "hardened_semantics": "Rust std::f64 math; no mode difference (pure computation)",
      "default_stub": false
    },
    {
      "symbol": "fopen",
      "status": "GlibcCallThrough",
      "module": "stdio_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Delegates to host glibc FILE* ops after membrane validation; preserves host semantics",
      "hardened_semantics": "Host glibc delegation; hardened membrane bounds C string scans, logs TruncateWithNull",
      "default_stub": false
    },
    {
      "symbol": "fork",
      "status": "RawSyscall",
      "module": "process_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for process control; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; validates argv/envp pointer arrays before execve",
      "default_stub": false
    },
    {
      "symbol": "fprintf",
      "status": "GlibcCallThrough",
      "module": "stdio_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Delegates to host glibc FILE* ops after membrane validation; preserves host semantics",
      "hardened_semantics": "Host glibc delegation; hardened membrane bounds C string scans, logs TruncateWithNull",
      "default_stub": false
    },
    {
      "symbol": "fputc",
      "status": "Implemented",
      "module": "stdio_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Native stream-registry + syscall-backed stdio path; no host glibc call-through",
      "hardened_semantics": "Native stream-registry + syscall-backed stdio path with membrane validation/repair; no host glibc call-through",
      "default_stub": false
    },
    {
      "symbol": "fputs",
      "status": "GlibcCallThrough",
      "module": "stdio_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Delegates to host glibc FILE* ops after membrane validation; preserves host semantics",
      "hardened_semantics": "Host glibc delegation; hardened membrane bounds C string scans, logs TruncateWithNull",
      "default_stub": false
    },
    {
      "symbol": "fread",
      "status": "GlibcCallThrough",
      "module": "stdio_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Delegates to host glibc FILE* ops after membrane validation; preserves host semantics",
      "hardened_semantics": "Host glibc delegation; hardened membrane bounds C string scans, logs TruncateWithNull",
      "default_stub": false
    },
    {
      "symbol": "free",
      "status": "Implemented",
      "module": "malloc_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Safe Rust arena allocator; null on failure; double-free silently ignored",
      "hardened_semantics": "Arena with healing: foreign-ptr realloc as malloc, double-free logged as HealingAction",
      "default_stub": false
    },
    {
      "symbol": "freeaddrinfo",
      "status": "Implemented",
      "module": "resolv_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Bootstrap resolver implementation: numeric getaddrinfo/getnameinfo + gai_strerror/freeaddrinfo with deterministic EAI_* failures",
      "hardened_semantics": "Resolver with deterministic repairs: invalid host/service normalized to safe defaults, evidence emitted",
      "default_stub": false
    },
    {
      "symbol": "fseek",
      "status": "GlibcCallThrough",
      "module": "stdio_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Delegates to host glibc FILE* ops after membrane validation; preserves host semantics",
      "hardened_semantics": "Host glibc delegation; hardened membrane bounds C string scans, logs TruncateWithNull",
      "default_stub": false
    },
    {
      "symbol": "fstat",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for POSIX I/O and process queries; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; clamps read/write count to tracked buffer bounds, defaults invalid whence/amode",
      "default_stub": false
    },
    {
      "symbol": "fsync",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for POSIX I/O and process queries; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; clamps read/write count to tracked buffer bounds, defaults invalid whence/amode",
      "default_stub": false
    },
    {
      "symbol": "ftell",
      "status": "GlibcCallThrough",
      "module": "stdio_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Delegates to host glibc FILE* ops after membrane validation; preserves host semantics",
      "hardened_semantics": "Host glibc delegation; hardened membrane bounds C string scans, logs TruncateWithNull",
      "default_stub": false
    },
    {
      "symbol": "fwrite",
      "status": "GlibcCallThrough",
      "module": "stdio_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Delegates to host glibc FILE* ops after membrane validation; preserves host semantics",
      "hardened_semantics": "Host glibc delegation; hardened membrane bounds C string scans, logs TruncateWithNull",
      "default_stub": false
    },
    {
      "symbol": "gai_strerror",
      "status": "Implemented",
      "module": "resolv_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Bootstrap resolver implementation: numeric getaddrinfo/getnameinfo + gai_strerror/freeaddrinfo with deterministic EAI_* failures",
      "hardened_semantics": "Resolver with deterministic repairs: invalid host/service normalized to safe defaults, evidence emitted",
      "default_stub": false
    },
    {
      "symbol": "getaddrinfo",
      "status": "Implemented",
      "module": "resolv_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Bootstrap resolver implementation: numeric getaddrinfo/getnameinfo + gai_strerror/freeaddrinfo with deterministic EAI_* failures",
      "hardened_semantics": "Resolver with deterministic repairs: invalid host/service normalized to safe defaults, evidence emitted",
      "default_stub": false
    },
    {
      "symbol": "getchar",
      "status": "Implemented",
      "module": "stdio_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Native stream-registry + syscall-backed stdio path; no host glibc call-through",
      "hardened_semantics": "Native stream-registry + syscall-backed stdio path with membrane validation/repair; no host glibc call-through",
      "default_stub": false
    },
    {
      "symbol": "getcwd",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for POSIX I/O and process queries; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; clamps read/write count to tracked buffer bounds, defaults invalid whence/amode",
      "default_stub": false
    },
    {
      "symbol": "getegid",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for POSIX I/O and process queries; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; clamps read/write count to tracked buffer bounds, defaults invalid whence/amode",
      "default_stub": false
    },
    {
      "symbol": "getenv",
      "status": "Implemented",
      "module": "stdlib_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Safe Rust stdlib (atoi/qsort/bsearch); POSIX-correct return values and errno",
      "hardened_semantics": "Stdlib with hardened membrane; repair clamping on comparator bounds",
      "default_stub": false
    },
    {
      "symbol": "geteuid",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for POSIX I/O and process queries; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; clamps read/write count to tracked buffer bounds, defaults invalid whence/amode",
      "default_stub": false
    },
    {
      "symbol": "getgid",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for POSIX I/O and process queries; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; clamps read/write count to tracked buffer bounds, defaults invalid whence/amode",
      "default_stub": false
    },
    {
      "symbol": "getgrent",
      "status": "Implemented",
      "module": "grp_abi",
      "perf_class": "coldpath",
      "strict_semantics": "NSS files backend: iterates /etc/group entries sequentially",
      "hardened_semantics": "NSS files backend with membrane validation",
      "default_stub": false
    },
    {
      "symbol": "getgrgid",
      "status": "Implemented",
      "module": "grp_abi",
      "perf_class": "coldpath",
      "strict_semantics": "NSS files backend: looks up /etc/group by GID, returns thread-local static storage",
      "hardened_semantics": "NSS files backend with membrane validation",
      "default_stub": false
    },
    {
      "symbol": "getgrgid_r",
      "status": "Implemented",
      "module": "grp_abi",
      "perf_class": "coldpath",
      "strict_semantics": "NSS files backend: reentrant getgrgid into caller buffer, ERANGE on insufficient space",
      "hardened_semantics": "NSS files backend with membrane validation",
      "default_stub": false
    },
    {
      "symbol": "getgrnam",
      "status": "Implemented",
      "module": "grp_abi",
      "perf_class": "coldpath",
      "strict_semantics": "NSS files backend: looks up /etc/group by name, returns thread-local static storage",
      "hardened_semantics": "NSS files backend with membrane validation",
      "default_stub": false
    },
    {
      "symbol": "getgrnam_r",
      "status": "Implemented",
      "module": "grp_abi",
      "perf_class": "coldpath",
      "strict_semantics": "NSS files backend: reentrant getgrnam into caller buffer, ERANGE on insufficient space",
      "hardened_semantics": "NSS files backend with membrane validation",
      "default_stub": false
    },
    {
      "symbol": "getnameinfo",
      "status": "Implemented",
      "module": "resolv_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Bootstrap resolver implementation: numeric getaddrinfo/getnameinfo + gai_strerror/freeaddrinfo with deterministic EAI_* failures",
      "hardened_semantics": "Resolver with deterministic repairs: invalid host/service normalized to safe defaults, evidence emitted",
      "default_stub": false
    },
    {
      "symbol": "getpeername",
      "status": "RawSyscall",
      "module": "socket_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for BSD sockets; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; clamps send/recv buffer lengths to tracked bounds",
      "default_stub": false
    },
    {
      "symbol": "getpid",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for POSIX I/O and process queries; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; clamps read/write count to tracked buffer bounds, defaults invalid whence/amode",
      "default_stub": false
    },
    {
      "symbol": "getppid",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for POSIX I/O and process queries; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; clamps read/write count to tracked buffer bounds, defaults invalid whence/amode",
      "default_stub": false
    },
    {
      "symbol": "getpwent",
      "status": "Implemented",
      "module": "pwd_abi",
      "perf_class": "coldpath",
      "strict_semantics": "NSS files backend: iterates /etc/passwd entries sequentially",
      "hardened_semantics": "NSS files backend with membrane validation",
      "default_stub": false
    },
    {
      "symbol": "getpwnam",
      "status": "Implemented",
      "module": "pwd_abi",
      "perf_class": "coldpath",
      "strict_semantics": "NSS files backend: looks up /etc/passwd by username, returns thread-local static storage",
      "hardened_semantics": "NSS files backend with membrane validation",
      "default_stub": false
    },
    {
      "symbol": "getpwnam_r",
      "status": "Implemented",
      "module": "pwd_abi",
      "perf_class": "coldpath",
      "strict_semantics": "NSS files backend: reentrant getpwnam into caller buffer, ERANGE on insufficient space",
      "hardened_semantics": "NSS files backend with membrane validation",
      "default_stub": false
    },
    {
      "symbol": "getpwuid",
      "status": "Implemented",
      "module": "pwd_abi",
      "perf_class": "coldpath",
      "strict_semantics": "NSS files backend: looks up /etc/passwd by UID, returns thread-local static storage",
      "hardened_semantics": "NSS files backend with membrane validation",
      "default_stub": false
    },
    {
      "symbol": "getpwuid_r",
      "status": "Implemented",
      "module": "pwd_abi",
      "perf_class": "coldpath",
      "strict_semantics": "NSS files backend: reentrant getpwuid into caller buffer, ERANGE on insufficient space",
      "hardened_semantics": "NSS files backend with membrane validation",
      "default_stub": false
    },
    {
      "symbol": "getrlimit",
      "status": "RawSyscall",
      "module": "resource_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for getrlimit/setrlimit; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; denies invalid resource constants",
      "default_stub": false
    },
    {
      "symbol": "getsockname",
      "status": "RawSyscall",
      "module": "socket_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for BSD sockets; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; clamps send/recv buffer lengths to tracked bounds",
      "default_stub": false
    },
    {
      "symbol": "getsockopt",
      "status": "RawSyscall",
      "module": "socket_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for BSD sockets; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; clamps send/recv buffer lengths to tracked bounds",
      "default_stub": false
    },
    {
      "symbol": "getuid",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for POSIX I/O and process queries; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; clamps read/write count to tracked buffer bounds, defaults invalid whence/amode",
      "default_stub": false
    },
    {
      "symbol": "htonl",
      "status": "Implemented",
      "module": "inet_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Pure-computation byte-order and address conversion; no syscalls",
      "hardened_semantics": "Pure computation; no mode difference",
      "default_stub": false
    },
    {
      "symbol": "htons",
      "status": "Implemented",
      "module": "inet_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Pure-computation byte-order and address conversion; no syscalls",
      "hardened_semantics": "Pure computation; no mode difference",
      "default_stub": false
    },
    {
      "symbol": "iconv",
      "status": "Implemented",
      "module": "iconv_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Phase-1 iconv implementation for UTF-8/ISO-8859-1/UTF-16LE with deterministic errno semantics",
      "hardened_semantics": "Phase-1 iconv with hardened membrane routing; deterministic bounds/error behavior",
      "default_stub": false
    },
    {
      "symbol": "iconv_close",
      "status": "Implemented",
      "module": "iconv_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Phase-1 iconv implementation for UTF-8/ISO-8859-1/UTF-16LE with deterministic errno semantics",
      "hardened_semantics": "Phase-1 iconv with hardened membrane routing; deterministic bounds/error behavior",
      "default_stub": false
    },
    {
      "symbol": "iconv_open",
      "status": "Implemented",
      "module": "iconv_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Phase-1 iconv implementation for UTF-8/ISO-8859-1/UTF-16LE with deterministic errno semantics",
      "hardened_semantics": "Phase-1 iconv with hardened membrane routing; deterministic bounds/error behavior",
      "default_stub": false
    },
    {
      "symbol": "inet_addr",
      "status": "Implemented",
      "module": "inet_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Pure-computation byte-order and address conversion; no syscalls",
      "hardened_semantics": "Pure computation; no mode difference",
      "default_stub": false
    },
    {
      "symbol": "inet_ntop",
      "status": "Implemented",
      "module": "inet_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Pure-computation byte-order and address conversion; no syscalls",
      "hardened_semantics": "Pure computation; no mode difference",
      "default_stub": false
    },
    {
      "symbol": "inet_pton",
      "status": "Implemented",
      "module": "inet_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Pure-computation byte-order and address conversion; no syscalls",
      "hardened_semantics": "Pure computation; no mode difference",
      "default_stub": false
    },
    {
      "symbol": "isalnum",
      "status": "Implemented",
      "module": "ctype_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Lookup-table ctype classification; returns 0/1 per POSIX C locale",
      "hardened_semantics": "Lookup-table ctype; no mode difference (pure computation)",
      "default_stub": false
    },
    {
      "symbol": "isalpha",
      "status": "Implemented",
      "module": "ctype_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Lookup-table ctype classification; returns 0/1 per POSIX C locale",
      "hardened_semantics": "Lookup-table ctype; no mode difference (pure computation)",
      "default_stub": false
    },
    {
      "symbol": "isatty",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for POSIX I/O and process queries; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; clamps read/write count to tracked buffer bounds, defaults invalid whence/amode",
      "default_stub": false
    },
    {
      "symbol": "isdigit",
      "status": "Implemented",
      "module": "ctype_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Lookup-table ctype classification; returns 0/1 per POSIX C locale",
      "hardened_semantics": "Lookup-table ctype; no mode difference (pure computation)",
      "default_stub": false
    },
    {
      "symbol": "islower",
      "status": "Implemented",
      "module": "ctype_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Lookup-table ctype classification; returns 0/1 per POSIX C locale",
      "hardened_semantics": "Lookup-table ctype; no mode difference (pure computation)",
      "default_stub": false
    },
    {
      "symbol": "isprint",
      "status": "Implemented",
      "module": "ctype_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Lookup-table ctype classification; returns 0/1 per POSIX C locale",
      "hardened_semantics": "Lookup-table ctype; no mode difference (pure computation)",
      "default_stub": false
    },
    {
      "symbol": "ispunct",
      "status": "Implemented",
      "module": "ctype_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Lookup-table ctype classification; returns 0/1 per POSIX C locale",
      "hardened_semantics": "Lookup-table ctype; no mode difference (pure computation)",
      "default_stub": false
    },
    {
      "symbol": "isspace",
      "status": "Implemented",
      "module": "ctype_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Lookup-table ctype classification; returns 0/1 per POSIX C locale",
      "hardened_semantics": "Lookup-table ctype; no mode difference (pure computation)",
      "default_stub": false
    },
    {
      "symbol": "isupper",
      "status": "Implemented",
      "module": "ctype_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Lookup-table ctype classification; returns 0/1 per POSIX C locale",
      "hardened_semantics": "Lookup-table ctype; no mode difference (pure computation)",
      "default_stub": false
    },
    {
      "symbol": "isxdigit",
      "status": "Implemented",
      "module": "ctype_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Lookup-table ctype classification; returns 0/1 per POSIX C locale",
      "hardened_semantics": "Lookup-table ctype; no mode difference (pure computation)",
      "default_stub": false
    },
    {
      "symbol": "kill",
      "status": "RawSyscall",
      "module": "signal_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for signal handling; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; denies invalid signal numbers instead of passing to kernel",
      "default_stub": false
    },
    {
      "symbol": "lgamma",
      "status": "Implemented",
      "module": "math_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Rust std::f64 math; returns NaN/Inf per IEEE 754; no repair",
      "hardened_semantics": "Rust std::f64 math; no mode difference (pure computation)",
      "default_stub": false
    },
    {
      "symbol": "link",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for POSIX I/O and process queries; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; clamps read/write count to tracked buffer bounds, defaults invalid whence/amode",
      "default_stub": false
    },
    {
      "symbol": "listen",
      "status": "RawSyscall",
      "module": "socket_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for BSD sockets; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; clamps send/recv buffer lengths to tracked bounds",
      "default_stub": false
    },
    {
      "symbol": "localeconv",
      "status": "Implemented",
      "module": "locale_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Bootstrap locale implementation: setlocale supports C/POSIX and localeconv returns static C locale struct",
      "hardened_semantics": "Locale implementation with hardened fallback to C locale defaults on invalid input",
      "default_stub": false
    },
    {
      "symbol": "localtime_r",
      "status": "RawSyscall",
      "module": "time_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for time queries; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; defaults invalid clock_id to CLOCK_REALTIME",
      "default_stub": false
    },
    {
      "symbol": "log",
      "status": "Implemented",
      "module": "math_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Rust std::f64 math; returns NaN/Inf per IEEE 754; no repair",
      "hardened_semantics": "Rust std::f64 math; no mode difference (pure computation)",
      "default_stub": false
    },
    {
      "symbol": "log10",
      "status": "Implemented",
      "module": "math_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Rust std::f64 math; returns NaN/Inf per IEEE 754; no repair",
      "hardened_semantics": "Rust std::f64 math; no mode difference (pure computation)",
      "default_stub": false
    },
    {
      "symbol": "lseek",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for POSIX I/O and process queries; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; clamps read/write count to tracked buffer bounds, defaults invalid whence/amode",
      "default_stub": false
    },
    {
      "symbol": "lstat",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for POSIX I/O and process queries; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; clamps read/write count to tracked buffer bounds, defaults invalid whence/amode",
      "default_stub": false
    },
    {
      "symbol": "madvise",
      "status": "RawSyscall",
      "module": "mmap_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for virtual memory; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; denies conflicting prot/flags combinations",
      "default_stub": false
    },
    {
      "symbol": "malloc",
      "status": "Implemented",
      "module": "malloc_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Safe Rust arena allocator; null on failure; double-free silently ignored",
      "hardened_semantics": "Arena with healing: foreign-ptr realloc as malloc, double-free logged as HealingAction",
      "default_stub": false
    },
    {
      "symbol": "memalign",
      "status": "Implemented",
      "module": "malloc_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Safe Rust arena allocator; null on failure; double-free silently ignored",
      "hardened_semantics": "Arena with healing: foreign-ptr realloc as malloc, double-free logged as HealingAction",
      "default_stub": false
    },
    {
      "symbol": "memchr",
      "status": "Implemented",
      "module": "string_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Safe Rust string/memory ops; unbounded scans follow C semantics; no repair",
      "hardened_semantics": "Clamps copy/scan to tracked allocation bounds; logs ClampSize/TruncateWithNull",
      "default_stub": false
    },
    {
      "symbol": "memcmp",
      "status": "Implemented",
      "module": "string_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Safe Rust string/memory ops; unbounded scans follow C semantics; no repair",
      "hardened_semantics": "Clamps copy/scan to tracked allocation bounds; logs ClampSize/TruncateWithNull",
      "default_stub": false
    },
    {
      "symbol": "memcpy",
      "status": "Implemented",
      "module": "string_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Safe Rust string/memory ops; unbounded scans follow C semantics; no repair",
      "hardened_semantics": "Clamps copy/scan to tracked allocation bounds; logs ClampSize/TruncateWithNull",
      "default_stub": false
    },
    {
      "symbol": "memmove",
      "status": "Implemented",
      "module": "string_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Safe Rust string/memory ops; unbounded scans follow C semantics; no repair",
      "hardened_semantics": "Clamps copy/scan to tracked allocation bounds; logs ClampSize/TruncateWithNull",
      "default_stub": false
    },
    {
      "symbol": "memrchr",
      "status": "Implemented",
      "module": "string_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Safe Rust string/memory ops; unbounded scans follow C semantics; no repair",
      "hardened_semantics": "Clamps copy/scan to tracked allocation bounds; logs ClampSize/TruncateWithNull",
      "default_stub": false
    },
    {
      "symbol": "memset",
      "status": "Implemented",
      "module": "string_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Safe Rust string/memory ops; unbounded scans follow C semantics; no repair",
      "hardened_semantics": "Clamps copy/scan to tracked allocation bounds; logs ClampSize/TruncateWithNull",
      "default_stub": false
    },
    {
      "symbol": "mmap",
      "status": "RawSyscall",
      "module": "mmap_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for virtual memory; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; denies conflicting prot/flags combinations",
      "default_stub": false
    },
    {
      "symbol": "mprotect",
      "status": "RawSyscall",
      "module": "mmap_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for virtual memory; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; denies conflicting prot/flags combinations",
      "default_stub": false
    },
    {
      "symbol": "msync",
      "status": "RawSyscall",
      "module": "mmap_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for virtual memory; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; denies conflicting prot/flags combinations",
      "default_stub": false
    },
    {
      "symbol": "munmap",
      "status": "RawSyscall",
      "module": "mmap_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for virtual memory; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; denies conflicting prot/flags combinations",
      "default_stub": false
    },
    {
      "symbol": "ntohl",
      "status": "Implemented",
      "module": "inet_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Pure-computation byte-order and address conversion; no syscalls",
      "hardened_semantics": "Pure computation; no mode difference",
      "default_stub": false
    },
    {
      "symbol": "ntohs",
      "status": "Implemented",
      "module": "inet_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Pure-computation byte-order and address conversion; no syscalls",
      "hardened_semantics": "Pure computation; no mode difference",
      "default_stub": false
    },
    {
      "symbol": "opendir",
      "status": "RawSyscall",
      "module": "dirent_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for directory enumeration; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; validates path pointer bounds before getdents64",
      "default_stub": false
    },
    {
      "symbol": "perror",
      "status": "GlibcCallThrough",
      "module": "stdio_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Delegates to host glibc FILE* ops after membrane validation; preserves host semantics",
      "hardened_semantics": "Host glibc delegation; hardened membrane bounds C string scans, logs TruncateWithNull",
      "default_stub": false
    },
    {
      "symbol": "pipe",
      "status": "RawSyscall",
      "module": "io_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for dup/dup2/pipe/fcntl; POSIX errno on failure",
      "hardened_semantics": "Raw syscall with hardened membrane; repair on invalid flags",
      "default_stub": false
    },
    {
      "symbol": "poll",
      "status": "RawSyscall",
      "module": "poll_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for I/O multiplexing; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; clamps nfds to tracked pollfd array bounds",
      "default_stub": false
    },
    {
      "symbol": "posix_memalign",
      "status": "Implemented",
      "module": "malloc_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Safe Rust arena allocator; null on failure; double-free silently ignored",
      "hardened_semantics": "Arena with healing: foreign-ptr realloc as malloc, double-free logged as HealingAction",
      "default_stub": false
    },
    {
      "symbol": "pow",
      "status": "Implemented",
      "module": "math_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Rust std::f64 math; returns NaN/Inf per IEEE 754; no repair",
      "hardened_semantics": "Rust std::f64 math; no mode difference (pure computation)",
      "default_stub": false
    },
    {
      "symbol": "ppoll",
      "status": "RawSyscall",
      "module": "poll_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for I/O multiplexing; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; clamps nfds to tracked pollfd array bounds",
      "default_stub": false
    },
    {
      "symbol": "printf",
      "status": "GlibcCallThrough",
      "module": "stdio_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Delegates to host glibc FILE* ops after membrane validation; preserves host semantics",
      "hardened_semantics": "Host glibc delegation; hardened membrane bounds C string scans, logs TruncateWithNull",
      "default_stub": false
    },
    {
      "symbol": "pselect",
      "status": "RawSyscall",
      "module": "poll_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for I/O multiplexing; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; clamps nfds to tracked pollfd array bounds",
      "default_stub": false
    },
    {
      "symbol": "pthread_cond_broadcast",
      "status": "Implemented",
      "module": "pthread_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Native futex-backed condvar implementation; requires managed mutex association and returns deterministic errno on invalid state",
      "hardened_semantics": "Native futex-backed condvar with deterministic validation of cond/mutex association and bounded wake behavior",
      "default_stub": false
    },
    {
      "symbol": "pthread_cond_destroy",
      "status": "Implemented",
      "module": "pthread_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Native condvar destroy returns EBUSY when waiters are present and clears association on success",
      "hardened_semantics": "Native condvar destroy enforces waiter-count invariants with deterministic EBUSY/EINVAL outcomes",
      "default_stub": false
    },
    {
      "symbol": "pthread_cond_init",
      "status": "Implemented",
      "module": "pthread_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Native condvar initialization with deterministic default clock and null/attr validation contract",
      "hardened_semantics": "Native condvar initialization with deterministic pointer validation and explicit unsupported-attribute rejection",
      "default_stub": false
    },
    {
      "symbol": "pthread_cond_signal",
      "status": "Implemented",
      "module": "pthread_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Native futex-backed condvar signal increments sequence and wakes one waiter when present",
      "hardened_semantics": "Native futex-backed condvar signal with deterministic wake policy and invariant-preserving sequence updates",
      "default_stub": false
    },
    {
      "symbol": "pthread_cond_wait",
      "status": "Implemented",
      "module": "pthread_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Native condvar wait with futex choreography; requires managed mutex and enforces association invariants",
      "hardened_semantics": "Native condvar wait with deterministic validation, bounded wake/relock path, and explicit EINVAL on invalid association",
      "default_stub": false
    },
    {
      "symbol": "pthread_create",
      "status": "Implemented",
      "module": "pthread_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Native clone-backed thread creation via core ThreadHandle; null thread_out/start rejected with EINVAL and non-null attr rejected deterministically",
      "hardened_semantics": "Native clone-backed thread creation with membrane policy gating and deterministic handle-registry ownership checks",
      "default_stub": false
    },
    {
      "symbol": "pthread_detach",
      "status": "Implemented",
      "module": "pthread_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Native detach on managed ThreadHandle registry; unknown or already-consumed thread ids return deterministic ESRCH",
      "hardened_semantics": "Native detach with membrane policy gating and deterministic registry ownership enforcement",
      "default_stub": false
    },
    {
      "symbol": "pthread_equal",
      "status": "Implemented",
      "module": "pthread_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Native pthread_t identity comparison (reflexive equality over managed handle ids and fallback tid ids)",
      "hardened_semantics": "Native identity comparison under membrane policy routing with deterministic 0/1 return",
      "default_stub": false
    },
    {
      "symbol": "pthread_join",
      "status": "Implemented",
      "module": "pthread_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Native join on managed ThreadHandle registry with deterministic ESRCH for unknown ids and core join errno propagation",
      "hardened_semantics": "Native join with membrane policy gating and deterministic registry ownership enforcement",
      "default_stub": false
    },
    {
      "symbol": "pthread_mutex_destroy",
      "status": "Implemented",
      "module": "pthread_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Futex-managed NORMAL mutex core; supports init(NULL attr) and lazy promotion for zero-initialized default mutexes; unsupported attributed/foreign layouts return deterministic EINVAL",
      "hardened_semantics": "Same futex-managed core with deterministic spin/wait/wake telemetry and identical errno contract",
      "default_stub": false
    },
    {
      "symbol": "pthread_mutex_init",
      "status": "Implemented",
      "module": "pthread_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Futex-managed NORMAL mutex core; supports init(NULL attr) and lazy promotion for zero-initialized default mutexes; unsupported attributed/foreign layouts return deterministic EINVAL",
      "hardened_semantics": "Same futex-managed core with deterministic spin/wait/wake telemetry and identical errno contract",
      "default_stub": false
    },
    {
      "symbol": "pthread_mutex_lock",
      "status": "Implemented",
      "module": "pthread_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Futex-managed NORMAL mutex core; supports init(NULL attr) and lazy promotion for zero-initialized default mutexes; unsupported attributed/foreign layouts return deterministic EINVAL",
      "hardened_semantics": "Same futex-managed core with deterministic spin/wait/wake telemetry and identical errno contract",
      "default_stub": false
    },
    {
      "symbol": "pthread_mutex_trylock",
      "status": "Implemented",
      "module": "pthread_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Futex-managed NORMAL mutex core; supports init(NULL attr) and lazy promotion for zero-initialized default mutexes; unsupported attributed/foreign layouts return deterministic EINVAL",
      "hardened_semantics": "Same futex-managed core with deterministic spin/wait/wake telemetry and identical errno contract",
      "default_stub": false
    },
    {
      "symbol": "pthread_mutex_unlock",
      "status": "Implemented",
      "module": "pthread_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Futex-managed NORMAL mutex core; supports init(NULL attr) and lazy promotion for zero-initialized default mutexes; unsupported attributed/foreign layouts return deterministic EINVAL",
      "hardened_semantics": "Same futex-managed core with deterministic spin/wait/wake telemetry and identical errno contract",
      "default_stub": false
    },
    {
      "symbol": "pthread_rwlock_destroy",
      "status": "Implemented",
      "module": "pthread_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Native futex-backed rwlock destroy; returns EBUSY when reader/writer state is active and EINVAL for unmanaged storage",
      "hardened_semantics": "Native futex-backed rwlock destroy with deterministic managed-state validation and explicit busy-state rejection",
      "default_stub": false
    },
    {
      "symbol": "pthread_rwlock_init",
      "status": "Implemented",
      "module": "pthread_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Native futex-backed rwlock init with deterministic managed magic tagging and null-attr requirement",
      "hardened_semantics": "Native futex-backed rwlock init with deterministic pointer validation and explicit unsupported-attribute rejection",
      "default_stub": false
    },
    {
      "symbol": "pthread_rwlock_rdlock",
      "status": "Implemented",
      "module": "pthread_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Native futex-backed read lock with reader-count state machine and deterministic EINVAL for unmanaged storage",
      "hardened_semantics": "Native futex-backed read lock with deterministic state validation and bounded wait behavior",
      "default_stub": false
    },
    {
      "symbol": "pthread_rwlock_unlock",
      "status": "Implemented",
      "module": "pthread_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Native futex-backed unlock for writer/reader holders; deterministic EPERM for unlocked state and EINVAL for unmanaged storage",
      "hardened_semantics": "Native futex-backed unlock with deterministic holder-state checks and wake-on-last-release behavior",
      "default_stub": false
    },
    {
      "symbol": "pthread_rwlock_wrlock",
      "status": "Implemented",
      "module": "pthread_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Native futex-backed write lock with exclusive writer state and deterministic EINVAL for unmanaged storage",
      "hardened_semantics": "Native futex-backed write lock with deterministic state validation and bounded wait behavior",
      "default_stub": false
    },
    {
      "symbol": "pthread_self",
      "status": "Implemented",
      "module": "pthread_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Native self id resolution: returns managed ThreadHandle-backed pthread_t when available, otherwise kernel tid fallback",
      "hardened_semantics": "Native self id resolution under membrane policy routing with deterministic managed-handle preference",
      "default_stub": false
    },
    {
      "symbol": "putchar",
      "status": "Implemented",
      "module": "stdio_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Native stream-registry + syscall-backed stdio path; no host glibc call-through",
      "hardened_semantics": "Native stream-registry + syscall-backed stdio path with membrane validation/repair; no host glibc call-through",
      "default_stub": false
    },
    {
      "symbol": "puts",
      "status": "GlibcCallThrough",
      "module": "stdio_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Delegates to host glibc FILE* ops after membrane validation; preserves host semantics",
      "hardened_semantics": "Host glibc delegation; hardened membrane bounds C string scans, logs TruncateWithNull",
      "default_stub": false
    },
    {
      "symbol": "qsort",
      "status": "Implemented",
      "module": "stdlib_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Safe Rust stdlib (atoi/qsort/bsearch); POSIX-correct return values and errno",
      "hardened_semantics": "Stdlib with hardened membrane; repair clamping on comparator bounds",
      "default_stub": false
    },
    {
      "symbol": "raise",
      "status": "RawSyscall",
      "module": "signal_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for signal handling; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; denies invalid signal numbers instead of passing to kernel",
      "default_stub": false
    },
    {
      "symbol": "read",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for POSIX I/O and process queries; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; clamps read/write count to tracked buffer bounds, defaults invalid whence/amode",
      "default_stub": false
    },
    {
      "symbol": "readdir",
      "status": "RawSyscall",
      "module": "dirent_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for directory enumeration; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; validates path pointer bounds before getdents64",
      "default_stub": false
    },
    {
      "symbol": "readlink",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for POSIX I/O and process queries; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; clamps read/write count to tracked buffer bounds, defaults invalid whence/amode",
      "default_stub": false
    },
    {
      "symbol": "realloc",
      "status": "Implemented",
      "module": "malloc_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Safe Rust arena allocator; null on failure; double-free silently ignored",
      "hardened_semantics": "Arena with healing: foreign-ptr realloc as malloc, double-free logged as HealingAction",
      "default_stub": false
    },
    {
      "symbol": "recv",
      "status": "RawSyscall",
      "module": "socket_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for BSD sockets; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; clamps send/recv buffer lengths to tracked bounds",
      "default_stub": false
    },
    {
      "symbol": "recvfrom",
      "status": "RawSyscall",
      "module": "socket_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for BSD sockets; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; clamps send/recv buffer lengths to tracked bounds",
      "default_stub": false
    },
    {
      "symbol": "rewind",
      "status": "Implemented",
      "module": "stdio_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Native stream-registry + syscall-backed stdio path; no host glibc call-through",
      "hardened_semantics": "Native stream-registry + syscall-backed stdio path with membrane validation/repair; no host glibc call-through",
      "default_stub": false
    },
    {
      "symbol": "rmdir",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for POSIX I/O and process queries; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; clamps read/write count to tracked buffer bounds, defaults invalid whence/amode",
      "default_stub": false
    },
    {
      "symbol": "round",
      "status": "Implemented",
      "module": "math_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Rust std::f64 math; returns NaN/Inf per IEEE 754; no repair",
      "hardened_semantics": "Rust std::f64 math; no mode difference (pure computation)",
      "default_stub": false
    },
    {
      "symbol": "select",
      "status": "RawSyscall",
      "module": "poll_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for I/O multiplexing; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; clamps nfds to tracked pollfd array bounds",
      "default_stub": false
    },
    {
      "symbol": "send",
      "status": "RawSyscall",
      "module": "socket_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for BSD sockets; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; clamps send/recv buffer lengths to tracked bounds",
      "default_stub": false
    },
    {
      "symbol": "sendto",
      "status": "RawSyscall",
      "module": "socket_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for BSD sockets; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; clamps send/recv buffer lengths to tracked bounds",
      "default_stub": false
    },
    {
      "symbol": "setbuf",
      "status": "GlibcCallThrough",
      "module": "stdio_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Delegates to host glibc FILE* ops after membrane validation; preserves host semantics",
      "hardened_semantics": "Host glibc delegation; hardened membrane bounds C string scans, logs TruncateWithNull",
      "default_stub": false
    },
    {
      "symbol": "setenv",
      "status": "Implemented",
      "module": "stdlib_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Safe Rust stdlib (atoi/qsort/bsearch); POSIX-correct return values and errno",
      "hardened_semantics": "Stdlib with hardened membrane; repair clamping on comparator bounds",
      "default_stub": false
    },
    {
      "symbol": "setgrent",
      "status": "Implemented",
      "module": "grp_abi",
      "perf_class": "coldpath",
      "strict_semantics": "NSS files backend: rewinds /etc/group iteration cursor",
      "hardened_semantics": "NSS files backend with membrane validation",
      "default_stub": false
    },
    {
      "symbol": "setlocale",
      "status": "Implemented",
      "module": "locale_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Bootstrap locale implementation: setlocale supports C/POSIX and localeconv returns static C locale struct",
      "hardened_semantics": "Locale implementation with hardened fallback to C locale defaults on invalid input",
      "default_stub": false
    },
    {
      "symbol": "setpwent",
      "status": "Implemented",
      "module": "pwd_abi",
      "perf_class": "coldpath",
      "strict_semantics": "NSS files backend: rewinds /etc/passwd iteration cursor",
      "hardened_semantics": "NSS files backend with membrane validation",
      "default_stub": false
    },
    {
      "symbol": "setrlimit",
      "status": "RawSyscall",
      "module": "resource_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for getrlimit/setrlimit; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; denies invalid resource constants",
      "default_stub": false
    },
    {
      "symbol": "setsockopt",
      "status": "RawSyscall",
      "module": "socket_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for BSD sockets; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; clamps send/recv buffer lengths to tracked bounds",
      "default_stub": false
    },
    {
      "symbol": "setvbuf",
      "status": "GlibcCallThrough",
      "module": "stdio_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Delegates to host glibc FILE* ops after membrane validation; preserves host semantics",
      "hardened_semantics": "Host glibc delegation; hardened membrane bounds C string scans, logs TruncateWithNull",
      "default_stub": false
    },
    {
      "symbol": "shutdown",
      "status": "RawSyscall",
      "module": "socket_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for BSD sockets; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; clamps send/recv buffer lengths to tracked bounds",
      "default_stub": false
    },
    {
      "symbol": "sigaction",
      "status": "RawSyscall",
      "module": "signal_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for signal handling; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; denies invalid signal numbers instead of passing to kernel",
      "default_stub": false
    },
    {
      "symbol": "signal",
      "status": "RawSyscall",
      "module": "signal_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for signal handling; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; denies invalid signal numbers instead of passing to kernel",
      "default_stub": false
    },
    {
      "symbol": "sin",
      "status": "Implemented",
      "module": "math_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Rust std::f64 math; returns NaN/Inf per IEEE 754; no repair",
      "hardened_semantics": "Rust std::f64 math; no mode difference (pure computation)",
      "default_stub": false
    },
    {
      "symbol": "sleep",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for POSIX I/O and process queries; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; clamps read/write count to tracked buffer bounds, defaults invalid whence/amode",
      "default_stub": false
    },
    {
      "symbol": "snprintf",
      "status": "GlibcCallThrough",
      "module": "stdio_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Delegates to host glibc FILE* ops after membrane validation; preserves host semantics",
      "hardened_semantics": "Host glibc delegation; hardened membrane bounds C string scans, logs TruncateWithNull",
      "default_stub": false
    },
    {
      "symbol": "socket",
      "status": "RawSyscall",
      "module": "socket_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for BSD sockets; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; clamps send/recv buffer lengths to tracked bounds",
      "default_stub": false
    },
    {
      "symbol": "sprintf",
      "status": "GlibcCallThrough",
      "module": "stdio_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Delegates to host glibc FILE* ops after membrane validation; preserves host semantics",
      "hardened_semantics": "Host glibc delegation; hardened membrane bounds C string scans, logs TruncateWithNull",
      "default_stub": false
    },
    {
      "symbol": "stat",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for POSIX I/O and process queries; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; clamps read/write count to tracked buffer bounds, defaults invalid whence/amode",
      "default_stub": false
    },
    {
      "symbol": "stderr",
      "status": "Implemented",
      "module": "stdio_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Native stream-registry + syscall-backed stdio path; no host glibc call-through",
      "hardened_semantics": "Native stream-registry + syscall-backed stdio path with membrane validation/repair; no host glibc call-through",
      "default_stub": false
    },
    {
      "symbol": "stdin",
      "status": "Implemented",
      "module": "stdio_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Native stream-registry + syscall-backed stdio path; no host glibc call-through",
      "hardened_semantics": "Native stream-registry + syscall-backed stdio path with membrane validation/repair; no host glibc call-through",
      "default_stub": false
    },
    {
      "symbol": "stdout",
      "status": "Implemented",
      "module": "stdio_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Native stream-registry + syscall-backed stdio path; no host glibc call-through",
      "hardened_semantics": "Native stream-registry + syscall-backed stdio path with membrane validation/repair; no host glibc call-through",
      "default_stub": false
    },
    {
      "symbol": "strcat",
      "status": "Implemented",
      "module": "string_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Safe Rust string/memory ops; unbounded scans follow C semantics; no repair",
      "hardened_semantics": "Clamps copy/scan to tracked allocation bounds; logs ClampSize/TruncateWithNull",
      "default_stub": false
    },
    {
      "symbol": "strchr",
      "status": "Implemented",
      "module": "string_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Safe Rust string/memory ops; unbounded scans follow C semantics; no repair",
      "hardened_semantics": "Clamps copy/scan to tracked allocation bounds; logs ClampSize/TruncateWithNull",
      "default_stub": false
    },
    {
      "symbol": "strcmp",
      "status": "Implemented",
      "module": "string_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Safe Rust string/memory ops; unbounded scans follow C semantics; no repair",
      "hardened_semantics": "Clamps copy/scan to tracked allocation bounds; logs ClampSize/TruncateWithNull",
      "default_stub": false
    },
    {
      "symbol": "strcpy",
      "status": "Implemented",
      "module": "string_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Safe Rust string/memory ops; unbounded scans follow C semantics; no repair",
      "hardened_semantics": "Clamps copy/scan to tracked allocation bounds; logs ClampSize/TruncateWithNull",
      "default_stub": false
    },
    {
      "symbol": "strlen",
      "status": "Implemented",
      "module": "string_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Safe Rust string/memory ops; unbounded scans follow C semantics; no repair",
      "hardened_semantics": "Clamps copy/scan to tracked allocation bounds; logs ClampSize/TruncateWithNull",
      "default_stub": false
    },
    {
      "symbol": "strncat",
      "status": "Implemented",
      "module": "string_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Safe Rust string/memory ops; unbounded scans follow C semantics; no repair",
      "hardened_semantics": "Clamps copy/scan to tracked allocation bounds; logs ClampSize/TruncateWithNull",
      "default_stub": false
    },
    {
      "symbol": "strncpy",
      "status": "Implemented",
      "module": "string_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Safe Rust string/memory ops; unbounded scans follow C semantics; no repair",
      "hardened_semantics": "Clamps copy/scan to tracked allocation bounds; logs ClampSize/TruncateWithNull",
      "default_stub": false
    },
    {
      "symbol": "strrchr",
      "status": "Implemented",
      "module": "string_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Safe Rust string/memory ops; unbounded scans follow C semantics; no repair",
      "hardened_semantics": "Clamps copy/scan to tracked allocation bounds; logs ClampSize/TruncateWithNull",
      "default_stub": false
    },
    {
      "symbol": "strstr",
      "status": "Implemented",
      "module": "string_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Safe Rust string/memory ops; unbounded scans follow C semantics; no repair",
      "hardened_semantics": "Clamps copy/scan to tracked allocation bounds; logs ClampSize/TruncateWithNull",
      "default_stub": false
    },
    {
      "symbol": "strtok",
      "status": "Implemented",
      "module": "string_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Safe Rust string/memory ops; unbounded scans follow C semantics; no repair",
      "hardened_semantics": "Clamps copy/scan to tracked allocation bounds; logs ClampSize/TruncateWithNull",
      "default_stub": false
    },
    {
      "symbol": "strtok_r",
      "status": "Implemented",
      "module": "string_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Safe Rust string/memory ops; unbounded scans follow C semantics; no repair",
      "hardened_semantics": "Clamps copy/scan to tracked allocation bounds; logs ClampSize/TruncateWithNull",
      "default_stub": false
    },
    {
      "symbol": "strtol",
      "status": "Implemented",
      "module": "stdlib_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Safe Rust stdlib (atoi/qsort/bsearch); POSIX-correct return values and errno",
      "hardened_semantics": "Stdlib with hardened membrane; repair clamping on comparator bounds",
      "default_stub": false
    },
    {
      "symbol": "strtoul",
      "status": "Implemented",
      "module": "stdlib_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Safe Rust stdlib (atoi/qsort/bsearch); POSIX-correct return values and errno",
      "hardened_semantics": "Stdlib with hardened membrane; repair clamping on comparator bounds",
      "default_stub": false
    },
    {
      "symbol": "symlink",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for POSIX I/O and process queries; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; clamps read/write count to tracked buffer bounds, defaults invalid whence/amode",
      "default_stub": false
    },
    {
      "symbol": "tan",
      "status": "Implemented",
      "module": "math_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Rust std::f64 math; returns NaN/Inf per IEEE 754; no repair",
      "hardened_semantics": "Rust std::f64 math; no mode difference (pure computation)",
      "default_stub": false
    },
    {
      "symbol": "tcdrain",
      "status": "RawSyscall",
      "module": "termios_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux ioctl for terminal control; POSIX errno on failure",
      "hardened_semantics": "Raw ioctl; validates termios struct pointer bounds",
      "default_stub": false
    },
    {
      "symbol": "tcflow",
      "status": "RawSyscall",
      "module": "termios_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux ioctl for terminal control; POSIX errno on failure",
      "hardened_semantics": "Raw ioctl; validates termios struct pointer bounds",
      "default_stub": false
    },
    {
      "symbol": "tcflush",
      "status": "RawSyscall",
      "module": "termios_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux ioctl for terminal control; POSIX errno on failure",
      "hardened_semantics": "Raw ioctl; validates termios struct pointer bounds",
      "default_stub": false
    },
    {
      "symbol": "tcgetattr",
      "status": "RawSyscall",
      "module": "termios_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux ioctl for terminal control; POSIX errno on failure",
      "hardened_semantics": "Raw ioctl; validates termios struct pointer bounds",
      "default_stub": false
    },
    {
      "symbol": "tcsendbreak",
      "status": "RawSyscall",
      "module": "termios_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux ioctl for terminal control; POSIX errno on failure",
      "hardened_semantics": "Raw ioctl; validates termios struct pointer bounds",
      "default_stub": false
    },
    {
      "symbol": "tcsetattr",
      "status": "RawSyscall",
      "module": "termios_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux ioctl for terminal control; POSIX errno on failure",
      "hardened_semantics": "Raw ioctl; validates termios struct pointer bounds",
      "default_stub": false
    },
    {
      "symbol": "tgamma",
      "status": "Implemented",
      "module": "math_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Rust std::f64 math; returns NaN/Inf per IEEE 754; no repair",
      "hardened_semantics": "Rust std::f64 math; no mode difference (pure computation)",
      "default_stub": false
    },
    {
      "symbol": "time",
      "status": "RawSyscall",
      "module": "time_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for time queries; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; defaults invalid clock_id to CLOCK_REALTIME",
      "default_stub": false
    },
    {
      "symbol": "tolower",
      "status": "Implemented",
      "module": "ctype_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Lookup-table ctype classification; returns 0/1 per POSIX C locale",
      "hardened_semantics": "Lookup-table ctype; no mode difference (pure computation)",
      "default_stub": false
    },
    {
      "symbol": "toupper",
      "status": "Implemented",
      "module": "ctype_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Lookup-table ctype classification; returns 0/1 per POSIX C locale",
      "hardened_semantics": "Lookup-table ctype; no mode difference (pure computation)",
      "default_stub": false
    },
    {
      "symbol": "ungetc",
      "status": "Implemented",
      "module": "stdio_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Native stream-registry + syscall-backed stdio path; no host glibc call-through",
      "hardened_semantics": "Native stream-registry + syscall-backed stdio path with membrane validation/repair; no host glibc call-through",
      "default_stub": false
    },
    {
      "symbol": "unlink",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for POSIX I/O and process queries; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; clamps read/write count to tracked buffer bounds, defaults invalid whence/amode",
      "default_stub": false
    },
    {
      "symbol": "unsetenv",
      "status": "Implemented",
      "module": "stdlib_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Safe Rust stdlib (atoi/qsort/bsearch); POSIX-correct return values and errno",
      "hardened_semantics": "Stdlib with hardened membrane; repair clamping on comparator bounds",
      "default_stub": false
    },
    {
      "symbol": "usleep",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for POSIX I/O and process queries; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; clamps read/write count to tracked buffer bounds, defaults invalid whence/amode",
      "default_stub": false
    },
    {
      "symbol": "wait",
      "status": "RawSyscall",
      "module": "process_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for process control; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; validates argv/envp pointer arrays before execve",
      "default_stub": false
    },
    {
      "symbol": "waitpid",
      "status": "RawSyscall",
      "module": "process_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for process control; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; validates argv/envp pointer arrays before execve",
      "default_stub": false
    },
    {
      "symbol": "wcscat",
      "status": "Implemented",
      "module": "wchar_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Safe Rust wide-char ops; follows C semantics; no repair",
      "hardened_semantics": "Clamps wide-char copy/scan to tracked allocation bounds; logs ClampSize",
      "default_stub": false
    },
    {
      "symbol": "wcschr",
      "status": "Implemented",
      "module": "wchar_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Safe Rust wide-char ops; follows C semantics; no repair",
      "hardened_semantics": "Clamps wide-char copy/scan to tracked allocation bounds; logs ClampSize",
      "default_stub": false
    },
    {
      "symbol": "wcscmp",
      "status": "Implemented",
      "module": "wchar_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Safe Rust wide-char ops; follows C semantics; no repair",
      "hardened_semantics": "Clamps wide-char copy/scan to tracked allocation bounds; logs ClampSize",
      "default_stub": false
    },
    {
      "symbol": "wcscpy",
      "status": "Implemented",
      "module": "wchar_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Safe Rust wide-char ops; follows C semantics; no repair",
      "hardened_semantics": "Clamps wide-char copy/scan to tracked allocation bounds; logs ClampSize",
      "default_stub": false
    },
    {
      "symbol": "wcslen",
      "status": "Implemented",
      "module": "wchar_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Safe Rust wide-char ops; follows C semantics; no repair",
      "hardened_semantics": "Clamps wide-char copy/scan to tracked allocation bounds; logs ClampSize",
      "default_stub": false
    },
    {
      "symbol": "wcsncmp",
      "status": "Implemented",
      "module": "wchar_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Safe Rust wide-char ops; follows C semantics; no repair",
      "hardened_semantics": "Clamps wide-char copy/scan to tracked allocation bounds; logs ClampSize",
      "default_stub": false
    },
    {
      "symbol": "wcsncpy",
      "status": "Implemented",
      "module": "wchar_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Safe Rust wide-char ops; follows C semantics; no repair",
      "hardened_semantics": "Clamps wide-char copy/scan to tracked allocation bounds; logs ClampSize",
      "default_stub": false
    },
    {
      "symbol": "wcsrchr",
      "status": "Implemented",
      "module": "wchar_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Safe Rust wide-char ops; follows C semantics; no repair",
      "hardened_semantics": "Clamps wide-char copy/scan to tracked allocation bounds; logs ClampSize",
      "default_stub": false
    },
    {
      "symbol": "wcsstr",
      "status": "Implemented",
      "module": "wchar_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Safe Rust wide-char ops; follows C semantics; no repair",
      "hardened_semantics": "Clamps wide-char copy/scan to tracked allocation bounds; logs ClampSize",
      "default_stub": false
    },
    {
      "symbol": "wmemchr",
      "status": "Implemented",
      "module": "wchar_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Safe Rust wide-char ops; follows C semantics; no repair",
      "hardened_semantics": "Clamps wide-char copy/scan to tracked allocation bounds; logs ClampSize",
      "default_stub": false
    },
    {
      "symbol": "wmemcmp",
      "status": "Implemented",
      "module": "wchar_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Safe Rust wide-char ops; follows C semantics; no repair",
      "hardened_semantics": "Clamps wide-char copy/scan to tracked allocation bounds; logs ClampSize",
      "default_stub": false
    },
    {
      "symbol": "wmemcpy",
      "status": "Implemented",
      "module": "wchar_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Safe Rust wide-char ops; follows C semantics; no repair",
      "hardened_semantics": "Clamps wide-char copy/scan to tracked allocation bounds; logs ClampSize",
      "default_stub": false
    },
    {
      "symbol": "wmemmove",
      "status": "Implemented",
      "module": "wchar_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Safe Rust wide-char ops; follows C semantics; no repair",
      "hardened_semantics": "Clamps wide-char copy/scan to tracked allocation bounds; logs ClampSize",
      "default_stub": false
    },
    {
      "symbol": "wmemset",
      "status": "Implemented",
      "module": "wchar_abi",
      "perf_class": "strict_hotpath",
      "strict_semantics": "Safe Rust wide-char ops; follows C semantics; no repair",
      "hardened_semantics": "Clamps wide-char copy/scan to tracked allocation bounds; logs ClampSize",
      "default_stub": false
    },
    {
      "symbol": "write",
      "status": "RawSyscall",
      "module": "unistd_abi",
      "perf_class": "coldpath",
      "strict_semantics": "Raw Linux syscall for POSIX I/O and process queries; POSIX errno on failure",
      "hardened_semantics": "Raw syscall; clamps read/write count to tracked buffer bounds, defaults invalid whence/amode",
      "default_stub": false
    }
  ],
  "summary": {
    "Implemented": 147,
    "RawSyscall": 83,
    "GlibcCallThrough": 20,
    "Stub": 0,
    "DefaultStub": 0
  }
}
